#LyX 1.6.10 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans helvet
\font_typewriter default
\font_default_family sfdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Yolk Manual
\end_layout

\begin_layout Date
Revised July 18th.
 2011
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
General Information
\end_layout

\begin_layout Section
What is Yolk?
\end_layout

\begin_layout Standard
Yolk is a collection of packages that aim to help build solid web-applications
 using Ada.
 Yolk itself doesn't do a whole lot that can't be accomplished simply by
 using 
\begin_inset CommandInset href
LatexCommand href
name "AWS"
target "http://libre.adacore.com/libre/tools/aws/"

\end_inset

 and the 
\begin_inset CommandInset href
LatexCommand href
name "GNAT Component Collection (GNATcoll)"
target "http://libre.adacore.com/libre/tools/gnat-component-collection/"

\end_inset

, but it does make the job of building complete web-applications a bit simpler.
 Things like changing user for the running application, accessing multiple
 databases, automatically cleaning up log files, adding basic static content
 handlers and building ATOM syndication XML are all handled by Yolk.
\end_layout

\begin_layout Standard
A Yolk application is in reality an AWS application, with some sugar added,
 so you're not really building a Yolk web-application, as much as you're
 building an AWS web-application.
 What I'm getting at, is that you need to understand how to use AWS, in
 order for Yolk to make any kind of sense.
 What you get when using Yolk is the little things that AWS does not readily
 provide.
\end_layout

\begin_layout Subsection
The Yolk demo application
\end_layout

\begin_layout Standard
Reading this manual will of course (I hope!) help you understand how to
 use Yolk, but please consider taking a closer look at the Yolk demo application
 to get a feel for how Yolk is actually used.
 The demo is heavily commented, so it should be fairly easy to understand
 what's going on.
 The demo application is also very suitable as a foundation for other AWS/Yolk
 applications.
\end_layout

\begin_layout Standard
It is much easier to show how to use Yolk, than it is to write down all
 possible usage scenarios.
 With the combination of this manual, the Yolk source files and the demo
 application, you should be able to make full use of the Yolk packages in
 your own applications.
\end_layout

\begin_layout Subsection
The source code
\end_layout

\begin_layout Standard
The Yolk source code is the best documentation there is.
 This document is never going to be as comprehensive as the actual source,
 so I'll strongly suggest having the source code available as you read this
 document.
 What you will find in this document are short descriptions of what a package
 is meant to do and small usage examples, not a complete rundown of every
 type and procedure in a package.
\end_layout

\begin_layout Subsection
Building and installing Yolk
\end_layout

\begin_layout Standard
See the README and INSTALL files.
 These are found in the Yolk root directory.
\end_layout

\begin_layout Subsection
The files Yolk depend upon
\end_layout

\begin_layout Standard
When you read this document and the Yolk source code, you'll notice that
 quite a few packages depend on various files being available at specified
 locations.
 This is for example the case with the 
\emph on
Yolk.Configuration
\emph default
 package, that must have a 
\emph on
config.ini
\emph default
 file available in the 
\emph on
configuration/
\emph default
 directory, or the 
\emph on
Yolk.Whoops
\emph default
 package that expects its template file to be found at the path 
\emph on
templates/system/500.tmpl
\end_layout

\begin_layout Standard
All such 
\begin_inset Quotes eld
\end_inset

dependencies
\begin_inset Quotes erd
\end_inset

 will of course be noted accordingly as we go along, but instead of forgetting
 one or more in your own application, I'd much rather encourage using the
 demo application as a foundation for your own applications, since all these
 fixed paths and files has been properly added to the demo.
\end_layout

\begin_layout Standard
I also recommend compiling and running the demo, to make sure your Yolk
 install is working as intended.
 Just read the 
\emph on
demo/README
\emph default
 and 
\emph on
demo/INSTALL
\emph default
 files for instructions on how to get it up and running.
\end_layout

\begin_layout Subsection
The Yolk packages naming
\end_layout

\begin_layout Standard
The Yolk packages are pretty diverse, ranging from process control to sending
 email.
 I've tried naming them as sensibly as possible, in the hope that the package
 names alone give away their function.
 If I've failed, well, you're just going to have to refer to this document
 or take a look at the source for yourself.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
The Yolk Packages
\end_layout

\begin_layout Section
Yolk
\end_layout

\begin_layout Standard
The Yolk main package currently only contain one thing: The Yolk 
\emph on
Version
\emph default
 string.
 This is used in a few places, for example in the 
\emph on
directory.tmpl
\emph default
 template file, but obviously it's not something that's of vital importance
 to most applications.
\end_layout

\begin_layout Section
Yolk.Cache.Discrete_Keys
\end_layout

\begin_layout Standard
If a piece of data doesn't change very often and it is expensive to build,
 then caching it might be worthwhile.
 Instead of going to file/database on every hit, you simply go to the cache
 and grab the latest version from there.
 This is 
\series bold
\emph on
very
\series default
\emph default
 fast, at the cost of some memory.
\end_layout

\begin_layout Standard
If you know exactly what you want to cache, the 
\emph on
Yolk.Cache.Discrete_Keys
\emph default
 package might be just what you need.
\end_layout

\begin_layout Subsection
The generic formal parameters
\end_layout

\begin_layout Standard
These are:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

generic
\end_layout

\begin_layout Plain Layout

   type Key_Type is (<>);
\end_layout

\begin_layout Plain Layout

   type Element_Type is private;
\end_layout

\begin_layout Plain Layout

   Max_Element_Age : Duration := 3600.0;
\end_layout

\begin_layout Plain Layout

package Yolk.Cache.Discrete_Keys is
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
Max_Element_Age
\emph default
 defaults to one hour.
 You should obviously set this to whatever suits your needs.
 This timer is used for all content in the cache.
 You cannot set this individually for each element.
\end_layout

\begin_layout Subsection
Instantiation
\end_layout

\begin_layout Standard
If for example we have two different sets of data (Foo and Bar) that are
 expensive to build, we can instantiate a 
\emph on
Discrete_Keys
\emph default
 package to handle this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

type Cache_Keys is (Foo, Bar);
\end_layout

\begin_layout Plain Layout

package My_Cache is new Yolk.Cache.Discrete_Keys
\end_layout

\begin_layout Plain Layout

  (Key_Type     => Cache_Keys,
\end_layout

\begin_layout Plain Layout

   Element_Type => Unbounded_String);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
And that is all.
 We now have a 
\emph on
My_Cache
\emph default
 object that can hold two objects: 
\emph on
Foo
\emph default
 and 
\emph on
Bar
\emph default
.
 These are of the type 
\emph on
Unbounded_String
\emph default
 and they have a 
\emph on
Max_Element_Age
\emph default
 of 3600.0 seconds.
\end_layout

\begin_layout Subsection
Writing to the cache
\end_layout

\begin_layout Standard
Before we can read something from the cache, we must first write something
 to it:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   Foo_Value : Unbounded_String := To_Unbounded_String ("Foo");
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   My_Cache.Write (Key   => Foo,
\end_layout

\begin_layout Plain Layout

                   Value => Foo_Value);
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is all it takes: 
\begin_inset Quotes eld
\end_inset

Foo
\begin_inset Quotes erd
\end_inset

 is now safely tucked away in the 
\emph on
My_Cache
\emph default
 object, and will be so for 3600.0 seconds.
 Calling 
\emph on
Write
\emph default
 with the 
\emph on
Foo 
\emph default
key will always overwrite earlier written 
\emph on
Foo
\emph default
 elements, no matter their age.
\end_layout

\begin_layout Subsection
Reading from the cache
\end_layout

\begin_layout Standard
A cache obviously only makes sense if you intend to read from it.
 In our case we want to get our hands on the previously written 
\begin_inset Quotes eld
\end_inset

Foo
\begin_inset Quotes erd
\end_inset

 value:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   Valid : Boolean := False;
\end_layout

\begin_layout Plain Layout

   Value : Unbounded_String;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   My_Cache.Read (Key      => Foo,
\end_layout

\begin_layout Plain Layout

                  Is_Valid => Valid,
\end_layout

\begin_layout Plain Layout

                  Value    => Value);
\end_layout

\begin_layout Plain Layout

   if Valid then
\end_layout

\begin_layout Plain Layout

      --  do something interesting with the data
\end_layout

\begin_layout Plain Layout

   else
\end_layout

\begin_layout Plain Layout

      --  the Foo data is invalid.
\end_layout

\begin_layout Plain Layout

   end if;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order for an element to be valid (the
\emph on
 Is_Valid
\emph default
 parameter is true), it must:
\end_layout

\begin_layout Enumerate
have been added to the cache in the first place
\end_layout

\begin_layout Enumerate
be younger than 
\emph on
Max_Element_Age
\end_layout

\begin_layout Standard
If 
\emph on
Is_Valid
\emph default
 is 
\emph on
False
\emph default
, then 
\emph on
Value
\emph default
 contains undefined garbage.
\end_layout

\begin_layout Subsection
Checking if a key is valid
\end_layout

\begin_layout Standard
If you need to check whether a specific key exists in the cache and is valid,
 then you need to use the 
\emph on
Is_Valid
\emph default
 function.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

if My_Cache.Is_Valid (Foo) then
\end_layout

\begin_layout Plain Layout

   --  Foo is good!
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

   --  Foo is bad!
\end_layout

\begin_layout Plain Layout

end if;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This follows the same rules as the 
\emph on
Is_Valid
\emph default
 parameter for the 
\emph on
Read
\emph default
 procedure.
\end_layout

\begin_layout Subsection
Clearing keys and the entire cache
\end_layout

\begin_layout Standard
For clearing of keys and the entire cache we have, naturally, two 
\emph on
Clear
\emph default
 procedures:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

-- First we clear the Foo key
\end_layout

\begin_layout Plain Layout

My_Cache.Clear (Key => Foo);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--  And then we clear the entire cache
\end_layout

\begin_layout Plain Layout

My_Cache.Clear;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
And that's all it takes.
\end_layout

\begin_layout Section
Yolk.Cache.String_Keys
\end_layout

\begin_layout Standard
This package is almost similar to the 
\emph on
Yolk.Cache.Discrete_Keys
\emph default
 package.
 The biggest difference is that where the 
\emph on
Discrete_Keys
\emph default
 cache package requires that you define a type for the keys, this packages
 takes a regular 
\emph on
String
\emph default
 as key.
\end_layout

\begin_layout Standard
The implications of this difference between the two cache packages are subtle.
 Both have the same 
\emph on
Read
\emph default
, 
\emph on
Write
\emph default
, 
\emph on
Is_Valid
\emph default
 and 
\emph on
Clear
\emph default
 procedures and functions, so in that sense the two packages are the same.
 The biggest difference lies in the available generic formal parameters
 and the addition of the 
\emph on
Cleanup
\emph default
 procedure and the 
\emph on
Length
\emph default
 function.
\end_layout

\begin_layout Subsection
The generic formal parameters
\end_layout

\begin_layout Standard
These are:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

generic
\end_layout

\begin_layout Plain Layout

   type Element_Type is private;
\end_layout

\begin_layout Plain Layout

   Cleanup_Size      : Positive := 200;
\end_layout

\begin_layout Plain Layout

   Cleanup_On_Write  : Boolean  := True;
\end_layout

\begin_layout Plain Layout

   Max_Element_Age   : Duration := 3600.0;
\end_layout

\begin_layout Plain Layout

   Reserved_Capacity : Positive := 100;
\end_layout

\begin_layout Plain Layout

package Yolk.Cache.Discrete_Keys is
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the amount of elements in the cache >= 
\emph on
Cleanup_Size
\emph default
, then the 
\emph on
Cleanup
\emph default
 procedure is called by 
\emph on
Write
\emph default
, if 
\emph on
Cleanup_On_Write
\emph default
 is set to Boolean 
\emph on
True
\emph default
.
 
\emph on
Cleanup_Size
\emph default
 is a sort of failsafe for this cache package.
 Since we can't know for sure what is being added (we don't know the keys
 beforehand), we need to make sure it doesn't gobble up all available resources.
 Set this number high enough that it'll never tricker under normal circumstances
, but low enough that it'll prevent resource exhaustion in case of errors.
\end_layout

\begin_layout Standard
The 
\emph on
Max_Element_Age
\emph default
 defaults to one hour.
 You should obviously set this to whatever suits your needs.
 This timer is used for all content in the cache.
 You cannot set this individually for each element.
\end_layout

\begin_layout Standard

\emph on
Reserved_Capacity
\emph default
 should be set as close as possible to the expected final size of the cache.
 If your best guestimate is 200 elements in the cache, then set this to
 200.
 Note that this setting has no bearing has no bearing on the actual size
 of the cache.
 The cache will happily grow beyond the 
\emph on
Reserved_Capacity
\emph default
 value.
\end_layout

\begin_layout Subsection
Instantiation
\end_layout

\begin_layout Standard
Instantiating 
\emph on
String_Keys
\emph default
 is done like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

package My_Cache is new Yolk.Cache.String_Keys
\end_layout

\begin_layout Plain Layout

  (Element_Type      => Unbounded_String,
\end_layout

\begin_layout Plain Layout

   Reserved_Capacity => 200);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
And that is all.
 We now have a 
\emph on
My_Cache
\emph default
 object that can hold 200 objects of the type 
\emph on
Unbounded_String
\emph default
, all of which have a 
\emph on
Max_Element_Age
\emph default
 of 3600.0 seconds.
 
\end_layout

\begin_layout Subsection
Writing to the cache
\end_layout

\begin_layout Standard
Before we can read something from the cache, we must first write something
 to it:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   Value : Unbounded_String := To_Unbounded_String ("42");
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   My_Cache.Write (Key   => "Foo",
\end_layout

\begin_layout Plain Layout

                   Value => Value);
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
That is all it takes: 
\begin_inset Quotes eld
\end_inset

42
\begin_inset Quotes erd
\end_inset

 is now safely tucked away in the 
\emph on
My_Cache
\emph default
 object under the key 
\begin_inset Quotes eld
\end_inset

Foo
\begin_inset Quotes erd
\end_inset

, and will be so for 3600.0 seconds.
 Calling 
\emph on
Write
\emph default
 with the 
\begin_inset Quotes eld
\end_inset

Foo
\begin_inset Quotes erd
\end_inset


\emph on
 
\emph default
String will always overwrite earlier written 
\begin_inset Quotes eld
\end_inset

Foo
\begin_inset Quotes erd
\end_inset

 elements, no matter their age.
\end_layout

\begin_layout Subsection
Reading from the cache
\end_layout

\begin_layout Standard
A cache obviously only makes sense if you intend to read from it.
 In our case we want to get our hands on the previously written 
\begin_inset Quotes eld
\end_inset

Foo
\begin_inset Quotes erd
\end_inset

 value:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   Valid : Boolean := False;
\end_layout

\begin_layout Plain Layout

   Value : Unbounded_String;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   My_Cache.Read (Key      => "Foo",
\end_layout

\begin_layout Plain Layout

                  Is_Valid => Valid,
\end_layout

\begin_layout Plain Layout

                  Value    => Value);
\end_layout

\begin_layout Plain Layout

   if Valid then
\end_layout

\begin_layout Plain Layout

      --  do something interesting with the data
\end_layout

\begin_layout Plain Layout

   else
\end_layout

\begin_layout Plain Layout

      --  the Foo data is invalid.
\end_layout

\begin_layout Plain Layout

   end if;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order for an element to be valid (the
\emph on
 Is_Valid
\emph default
 parameter is true), it must:
\end_layout

\begin_layout Enumerate
have been added to the cache in the first place
\end_layout

\begin_layout Enumerate
be younger than 
\emph on
Max_Element_Age
\end_layout

\begin_layout Standard
If 
\emph on
Is_Valid
\emph default
 is 
\emph on
False
\emph default
, then 
\emph on
Value
\emph default
 contains undefined garbage.
\end_layout

\begin_layout Subsection
Checking if a key is valid
\end_layout

\begin_layout Standard
If you need to check whether a specific key exists in the cache and is valid,
 then you need to use the 
\emph on
Is_Valid
\emph default
 function.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

if My_Cache.Is_Valid ("Foo") then
\end_layout

\begin_layout Plain Layout

   --  Foo is good!
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

   --  Foo is bad!
\end_layout

\begin_layout Plain Layout

end if;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This follows the same rules as the 
\emph on
Is_Valid
\emph default
 parameter for the 
\emph on
Read
\emph default
 procedure.
\end_layout

\begin_layout Subsection
Clearing keys and the entire cache
\end_layout

\begin_layout Standard
For clearing of keys and the entire cache we have, naturally, two 
\emph on
Clear
\emph default
 procedures:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

-- First we clear the Foo key
\end_layout

\begin_layout Plain Layout

My_Cache.Clear (Key => "Foo");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

--  And then we clear the entire cache
\end_layout

\begin_layout Plain Layout

My_Cache.Clear;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
And that's all it takes.
\end_layout

\begin_layout Subsection
How much is in there?
\end_layout

\begin_layout Standard
With the 
\emph on
Discrete_Keys
\emph default
 cache we obviously always now the exact amount of keys available, since
 we've defined the keys ourselves.
 This is not the case with the 
\emph on
String_Keys
\emph default
 cache, where any String can be a key.
 If we need to know how many elements that are currently in the cache, we
 call the 
\emph on
Length
\emph default
 function:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

if My_Cache.Length > 1000 then
\end_layout

\begin_layout Plain Layout

   --  Woa! Lots of stuff in the cache..
\end_layout

\begin_layout Plain Layout

end if;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\emph on
Length
\emph default
 count both valid and invalid elements.
\end_layout

\begin_layout Subsection
Cleanup - Keeping cache size in check
\end_layout

\begin_layout Standard
if 
\emph on
Cleanup_On_Write
\emph default
 is 
\emph on
True
\emph default
, then 
\emph on
Cleanup
\emph default
 is called by 
\emph on
Write 
\emph default
whenever the size of the cache reach 
\emph on
Cleanup_Size
\emph default
.
 It is of course also possible to call it manually:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

if My_Cache.Length > 1000 then
\end_layout

\begin_layout Plain Layout

   My_Cache.Cleanup;
\end_layout

\begin_layout Plain Layout

end if;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you've set 
\emph on
Cleanup_On_Write
\emph default
 to Boolean 
\emph on
False
\emph default
 and the String keys are coming from outside sources, then you really should
 make sure you call 
\emph on
Cleanup
\emph default
 on a regular basis.
 
\end_layout

\begin_layout Section
Yolk.Config_File_Parser
\end_layout

\begin_layout Standard
This package enable you to access KEY/VALUE pairs in configuration files
 that are written in the style:
\end_layout

\begin_layout LyX-Code
# This is a comment
\end_layout

\begin_layout LyX-Code
-- This is also a comment
\end_layout

\begin_layout LyX-Code
KEY VALUE
\end_layout

\begin_layout Standard
Keys are case-insensitive, so 
\emph on
FOO
\emph default
, 
\emph on
foo
\emph default
 and 
\emph on
fOo
\emph default
 are all the same.

\emph on
 
\emph default
Blank lines and comments are ignored and so is pre/postfixed whitespace.
 It is not necessary to quote values that contain whitespace, to this:
\end_layout

\begin_layout LyX-Code
KEY some value with whitespace
\end_layout

\begin_layout Standard
is perfectly valid, and will return 
\begin_inset Quotes eld
\end_inset


\emph on
some value with whitespace
\emph default

\begin_inset Quotes erd
\end_inset

 when calling 
\emph on
Get (KEY)
\emph default
.
 If VALUE is Boolean True or False (case-insensitive), then the KEY can
 be returned as a String or a Boolean, depending on the target type.
 If the target type does not match the VALUE and no sensible conversion
 can be made, then a 
\emph on
Conversion_Error
\emph default
 exception is raised.
 No dummy values are returned at any time.
\end_layout

\begin_layout Standard
To clear a default value, simply add the key to the configuration file,
 with no value set.
\end_layout

\begin_layout Subsection
The generic formal parameters
\end_layout

\begin_layout Standard
These are:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

generic
\end_layout

\begin_layout Plain Layout

   use Ada.Strings.Unbounded;
\end_layout

\begin_layout Plain Layout

   type Key_Type is (<>);
\end_layout

\begin_layout Plain Layout

   type Defaults_Array_Type is array (Key_Type) of Unbounded_String;
\end_layout

\begin_layout Plain Layout

   Defaults    : in Defaults_Array_Type;    
\end_layout

\begin_layout Plain Layout

   Config_File : in String := "configuration/config.ini";
\end_layout

\begin_layout Plain Layout

package Yolk.Config_File_Parser is
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the 
\emph on
Config_File
\emph default
 parameter has a default value.
 This path is actually where Yolk expects to find the configuration file
 used by the Yolk.Configuration package.
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
There are 3 different exceptions that can be raised by the 
\emph on
Yolk.Config_File_Parser
\emph default
 package.
 These are:
\end_layout

\begin_layout Itemize

\emph on
Unknown_Key
\emph default
.
 This is raised if an unknown key has been found in the configuration file
 given when instantiating the package or when 
\emph on
Load_File
\emph default
 is called.
\end_layout

\begin_layout Itemize

\emph on
Cannot_Open_Config_File
\emph default
.
 This is raised when a configuration file cannot be read.
\end_layout

\begin_layout Itemize

\emph on
Conversion_Error
\emph default
.
 This is raised when a value cannot be converted to the target type, ie.
 the value 
\begin_inset Quotes eld
\end_inset

42
\begin_inset Quotes erd
\end_inset

 to a Boolean.
\end_layout

\begin_layout Subsection
Instantiation
\end_layout

\begin_layout Standard

\emph on
Yolk.Config_File_Parser
\emph default
 is a generic package, so in order to use it, you have to instantiate it,
 like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

package My_Configuration is
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   type Keys is (Foo, Bar);
\end_layout

\begin_layout Plain Layout

   type Defaults_Array is array (Keys) of
\end_layout

\begin_layout Plain Layout

     Ada.Strings.Unbounded.Unbounded_String;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Default_Values : constant Defaults_Array :=
\end_layout

\begin_layout Plain Layout

                      (Foo => TUS ("some foo"),
\end_layout

\begin_layout Plain Layout

                       Bar => TUS ("some bar"));
\end_layout

\begin_layout Plain Layout

   --  TUS is a rename of the To_Unbounded_String function.
 It
\end_layout

\begin_layout Plain Layout

   --  is found in the Yolk.Utilities package.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   package Config is new Yolk.Config_File_Parser
\end_layout

\begin_layout Plain Layout

     (Key_Type => Keys,
\end_layout

\begin_layout Plain Layout

      Defaults_Array_Type => Defaults_Array,
\end_layout

\begin_layout Plain Layout

      Defaults => Default_Value,
\end_layout

\begin_layout Plain Layout

      Config_File => "config.ini");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end My_Configuration;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here we instantiate the 
\emph on
Config
\emph default
 package with 
\emph on
config.ini
\emph default
 as the configuration file.
 This means that KEY/VALUE pairs found in this file will overwrite the default
 values set in the 
\emph on
Default_Values
\emph default
 array.
 Setting a default value to 
\emph on
Null_Unbounded_String
\emph default
 means the value is empty.
\end_layout

\begin_layout Subsection
Re-loading configuration files
\end_layout

\begin_layout Standard
With the 
\emph on
Load_File
\emph default
 procedure you can re-load a new configuration file into your 
\emph on
Config
\emph default
 package:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

My_Configuration.Config.Load_File ("new_config.ini");
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
And that is all.
 Now the KEY/VALUE pairs of 
\emph on
new_config.ini
\emph default
 will overwrite the ones originally found in the 
\emph on
config.ini
\emph default
 file the package was instantiated with.
 You can do this as many times as you like.
 Note that you cannot change what KEY's are valid, so if the 
\emph on
new_config.ini
\emph default
 file contains unknown keys, 
\emph on
Load_File
\emph default
 will raise the 
\emph on
Unknown_Key
\emph default
 exception.
\end_layout

\begin_layout Subsection
Getting values
\end_layout

\begin_layout Standard
With instantiation and loading of configuration files out of the way, it
 is now time to get to the configuration values.
 To get the value of the 
\emph on
Foo
\emph default
 key, you do:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

My_Configuration.Config.Get (Foo);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are Get functions for the following types:
\end_layout

\begin_layout Itemize
Boolean
\end_layout

\begin_layout Itemize
Duration
\end_layout

\begin_layout Itemize
Float
\end_layout

\begin_layout Itemize
Integer
\end_layout

\begin_layout Itemize
String
\end_layout

\begin_layout Itemize
Unbounded_String
\end_layout

\begin_layout Standard
Empty keys simply return an empty String or a 
\emph on
Null_Unbounded_String
\emph default
, depending on the target type.
 If a key is empty and the target type is not a String or an Unbounded_String,
 then the 
\emph on
Conversion_Error
\emph default
 exception is raised.
\end_layout

\begin_layout Subsection
Checking if a KEY has a VALUE
\end_layout

\begin_layout Standard
You can check if a key has a value with the 
\emph on
Has_Value
\emph default
 function:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

if Has_Value (Foo) then
\end_layout

\begin_layout Plain Layout

   Put_Line ("Foo has a value");
\end_layout

\begin_layout Plain Layout

end if;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Basically all this function does is return Boolean True if the value of
 the given key is not a 
\emph on
Null_Unbounded_String
\emph default
.
\end_layout

\begin_layout Section
Yolk.Configuration
\end_layout

\begin_layout Standard
This package is a bit of an oddball, as all it does is instantiate the 
\emph on
Yolk.Config_File_Parser
\emph default
 generic with the default AWS and Yolk configuration values.
 This is used by Yolk internally, but also possibly by the AWS component
 of your application.
 The instantiation looks like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

package Config is new Config_File_Parser
\end_layout

\begin_layout Plain Layout

  (Key_Type => Keys,
\end_layout

\begin_layout Plain Layout

   Defaults_Array_Type => Defaults_Array,
\end_layout

\begin_layout Plain Layout

   Defaults => Default_Values,
\end_layout

\begin_layout Plain Layout

   Config_File => "configuration/config.ini");
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, it is required that there's a configuration file found in
 
\emph on
configuration/config.ini
\emph default
.
 This path is of course relative to the application.
 There's a fully commented 
\emph on
config.ini
\emph default
 file available in 
\emph on
demo/exe/configuration/
\emph default
.
 This setup is required if you're using Yolk, and the only way to avoid
 having 
\emph on
config.ini
\emph default
 in the mentioned directory is if you manually change the path in the source
 file before compiling Yolk.
\end_layout

\begin_layout Standard
I recommend taking a look at the Yolk demo application to see how the 
\emph on
Yolk.Configuration
\emph default
 package is used.
\end_layout

\begin_layout Subsection
Get the AWS specific configuration settings
\end_layout

\begin_layout Standard
When you start an AWS server, you need to give it an 
\emph on
AWS.Config.Object
\emph default
 with all the necessary configuration settings.
 This is already handled for you in 
\emph on
Yolk.Configuration
\emph default
, all you have to do is call the 
\emph on
Get_AWS_Configuration
\emph default
 function, like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

AWS_Config : constant AWS.Config.Object := 
\end_layout

\begin_layout Plain Layout

  Yolk.Configuration.Get_AWS_Configuration;
\end_layout

\begin_layout Plain Layout

AWS.Server.Start (Web_Server => Web_Server,
\end_layout

\begin_layout Plain Layout

                  Dispatcher => Resource_Handlers,
\end_layout

\begin_layout Plain Layout

                  Config     => AWS_Config);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You're not forced to use this, if you don't want to.
 But even if you don't, you'll still have to make a valid configuration
 file available in the configuration directory defined in the 
\emph on
Config
\emph default
 instantiation, so you might as well use this as the configuration foundation
 for the AWS HTTP server component of your application.
 Again, see the demo application for examples on how this is done.
\end_layout

\begin_layout Section
Yolk.Connect_To_DB
\end_layout

\begin_layout Standard
This is a small wrapper for the 
\emph on
GNATCOLL.SQL
\emph default
 database connection functionality.
 Once you've connected to the database, you use plain 
\emph on
GNATCOLL.SQL
\emph default
 tools to query/update your database.
 The ability to stay connected to several databases in the same application
 was what drove the development of the 
\emph on
Yolk.Connect_To_DB
\emph default
 package, as the 
\emph on
GNATCOLL.SQL.Exec.Get_Task_Connection
\emph default
 function did not support that out of the box.
\end_layout

\begin_layout Standard
At the time of writing, GNATcoll supports PostgreSQL and SQLite, but Yolk
 only supports connecting to PostgreSQL.
 The reason for this is simple: I don't use SQLite now and I don't plan
 on using it in the future, and if I can't test something, I don't feel
 like adding it to Yolk.
\end_layout

\begin_layout Subsection
The Connection_Mapping_Method type
\end_layout

\begin_layout Standard
To define how AWS threads are mapped to the database connections, you need
 to understand the 
\emph on
Connection_Mapping_Method
\emph default
 type.
 There are two different methods of connecting to a database:
\end_layout

\begin_layout Enumerate
AWS_Tasks_To_DB
\end_layout

\begin_layout Enumerate
DB_Conn_Tasks_To_DB
\end_layout

\begin_layout Standard
The first method is the simplest and it's also the method that requires
 fewest resources.
 Using method 1.
 we simply map each AWS thread to a database connection, meaning that if
 you have 5 AWS threads, you're going to end up with 5 open connections
 to your database.
 Whenever an AWS thread ask for a database connection, it always get the
 same connection.
 If no connection has been made yet, one is started and mapped to the AWS
 thread that started it.
\end_layout

\begin_layout Standard
This works flawlessly as long as you don't need to connect to more than
 one database, but it fails miserably if you have more than one database
 in play.
 For such cases we need option 2.
 
\end_layout

\begin_layout Standard
When option 2.
 is used, one set of database connection tasks are started for every database
 you connect to.
 So if you have an AWS server with 5 threads and you need to connect to
 two databases, you're going to end up with 5 small tasks whose only purpose
 in life is to open and maintain a connection to the database.
 These 5 
\emph on
DB_Conn
\emph default
 tasks are then mapped to the AWS threads using the 
\emph on
Ada.Task_Attributes
\emph default
 package.
\end_layout

\begin_layout Standard
This also means that you can only instantiate once using 
\emph on
AWS_Tasks_To_DB
\emph default
 whereas you can instantiate as many times as you like with 
\emph on
DB_Conn_Tasks_To_DB
\emph default
.
 If you need to connect to several databases, make sure that the one you
 use the most is setup with the 
\emph on
AWS_Tasks_To_DB
\emph default
 connection mapping.
 This is the fastest and most resource efficient method, as we don't have
 to spend time going through one of the 
\emph on
DB_Conn
\emph default
 tasks that are necessary with the 
\emph on
DB_Conn_Tasks_To_DB
\emph default
 method.
\end_layout

\begin_layout Subsection
Database credentials
\end_layout

\begin_layout Standard
The 
\emph on
Set_Credentials
\emph default
 function is responsible for setting the credentials necessary to connect
 to the database.
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

Yolk.Connect_To_DB.Set_Credentials
\end_layout

\begin_layout Plain Layout

  (Host     => "localhost",
\end_layout

\begin_layout Plain Layout

   Database => "some_database",
\end_layout

\begin_layout Plain Layout

   User     => "username",
\end_layout

\begin_layout Plain Layout

   Password => "secret");
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This call return a 
\emph on
Yolk.Connect_To_DB.Credentials
\emph default
 type which is then used when instantiating the 
\emph on
Yolk.Connect_To_DB.PostgreSQL
\emph default
 generic.
\end_layout

\begin_layout Section
Yolk.Connect_To_DB.PostgreSQL
\end_layout

\begin_layout Standard
When instantiated, this package provides a single function: 
\emph on
Connection
\emph default
.
 This function return a 
\emph on
GNATCOLL.SQL.Exec.Database_Connection
\emph default
 type, which is then used to interact with your database.
\end_layout

\begin_layout Subsection
The generic formal parameters
\end_layout

\begin_layout Standard
When you're actually going to connect to your PostgreSQL database(s), this
 is the package you want.
 It's a generic with two formal parameters:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

generic
\end_layout

\begin_layout Plain Layout

   DB_Credentials : Credentials;
\end_layout

\begin_layout Plain Layout

   Task_To_DB_Mapping_Method : Connection_Mapping_Method;    
\end_layout

\begin_layout Plain Layout

package Yolk.Connect_To_DB.PostgreSQL is
\end_layout

\begin_layout Plain Layout

   function Connection return GNATCOLL.SQL.Exec.Database_Connection;
\end_layout

\begin_layout Plain Layout

end Yolk.Connect_To_DB.PostgreSQL;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instantiation is pretty straightforward:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

package My_DB is new Connect_To_DB.PostgreSQL      
\end_layout

\begin_layout Plain Layout

  (DB_Credentials            => Connect_To_DB.Set_Credentials         
\end_layout

\begin_layout Plain Layout

     (Host     => My.Config.Get (My.DB_Host),          
\end_layout

\begin_layout Plain Layout

      Database => My.Config.Get (My.DB_Name),          
\end_layout

\begin_layout Plain Layout

      User     => My.Config.Get (My.DB_User),          
\end_layout

\begin_layout Plain Layout

      Password => My.Config.Get (My.DB_Password)), 
\end_layout

\begin_layout Plain Layout

   Task_To_DB_Mapping_Method => Connect_To_DB.AWS_Tasks_To_DB);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case we've used the 
\emph on
AWS_Tasks_To_DB
\emph default
 mapping method, so each AWS thread will be mapped to a specific database
 connection.
\end_layout

\begin_layout Subsection
Connecting to the database
\end_layout

\begin_layout Standard
With the 
\emph on
My_DB
\emph default
 package up and running, connecting to the database is done like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

DB_Conn : constant Database_Connection := My_DB.Connection;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
You can now use the 
\emph on
DB_Conn
\emph default
 connection just as if you'd created the 
\emph on
Database_Connection
\emph default
 object using the method described in the 
\begin_inset CommandInset href
LatexCommand href
name "GNAT Component Collection (GNATcoll) manual"
target "https://www.adacore.com/wp-content/files/auto_update/gnatcoll-docs/gnatcoll.html#Database-interface"

\end_inset

.
 There's also a usage example in the Yolk demo.
 Take a look at the 
\emph on
View.DB_Test
\emph default
 package.
\end_layout

\begin_layout Section
Yolk.Email
\end_layout

\begin_layout Standard
Using 
\emph on
Yolk.Email
\emph default
 and the child package 
\emph on
Yolk.Email.Composer
\emph default
 you can build and send more or less any kind of email:
\end_layout

\begin_layout Itemize
Plain text
\end_layout

\begin_layout Itemize
Multipart/Alternative
\end_layout

\begin_layout Itemize
Multipart/Mixed
\end_layout

\begin_layout Standard
The package supports adding multiple SMTP servers, meaning you can add as
 many as you need, and the email will then be send via the first one that
 accepts it.
\end_layout

\begin_layout Standard
The 
\emph on
Yolk.Email
\emph default
 package define 4 exceptions and 3 types.
 The facilities for actually constructing and sending the email are found
 in 
\emph on
Yolk.Email.Composer
\emph default
.
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
These are:
\end_layout

\begin_layout Itemize

\emph on
Attachment_File_Not_Found
\emph default
.
 Is raised if a file attachment is not found at the given path.
\end_layout

\begin_layout Itemize

\emph on
No_Address_Set
\emph default
.
 Is raised if the address component of a To, Reply-To, From, Bcc/Cc header
 is missing.
\end_layout

\begin_layout Itemize

\emph on
No_Sender_Set_With_Multiple_From
\emph default
.
 Is raised when an email contains multiple From headers but no Sender header,
 as per RFC-5322, 3.6.2.
 http://tools.ietf.org/html/rfc5322
\end_layout

\begin_layout Itemize

\emph on
No_SMTP_Host_Set
\emph default
.
 Is raised if the SMTP host list is empty, ie.
 no SMTP host has been set for sending the email.
\end_layout

\begin_layout Subsection
The Yolk.Email types
\end_layout

\begin_layout Standard
When using 
\emph on
Yolk.Email.Composer
\emph default
 to build and send emails, three types declared in 
\emph on
Yolk.Email
\emph default
 are central:
\end_layout

\begin_layout Enumerate

\emph on
Character_Set
\end_layout

\begin_layout Enumerate

\emph on
Recipient_Kind
\end_layout

\begin_layout Enumerate

\emph on
Structure
\end_layout

\begin_layout Standard
The 
\emph on
Character_Set
\emph default
 type define what character set is used when data is added to an email 
\emph on
Structure
\emph default
 object.
 For example looking at the 
\emph on
Yolk.Email.Composer.Add_From
\emph default
 procedure, we see that the 
\emph on
Charset
\emph default
 parameter defaults to 
\emph on
US_ASCII
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

procedure Add_From      
\end_layout

\begin_layout Plain Layout

  (ES        : in out Structure;       
\end_layout

\begin_layout Plain Layout

   Address   : in     String;       
\end_layout

\begin_layout Plain Layout

   Name      : in     String := "";       
\end_layout

\begin_layout Plain Layout

   Charset   : in     Character_Set := US_ASCII);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This does not mean that 
\emph on
Yolk.Email.Composer.Add_From
\emph default
 will encode 
\emph on
Name
\emph default
 as 
\emph on
US_ASCII
\emph default
, instead it means that the data given in 
\emph on
Name
\emph default
 is already encoded as 
\emph on
US_ASCII
\emph default
.
 So if 
\emph on
Name
\emph default
 had contained an ISO-8859-1 encoded String, then the call would've looked
 like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   use Yolk.Email;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Email : Structure;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   Composer.Add_From      
\end_layout

\begin_layout Plain Layout

     (ES        => Email,       
\end_layout

\begin_layout Plain Layout

      Address   => "thomas@12boo.net",
\end_layout

\begin_layout Plain Layout

      Name      => "Thomas Lcke",
\end_layout

\begin_layout Plain Layout

      Charset   => ISO_8859_1);
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case you will end up with a From header looking like this:
\end_layout

\begin_layout LyX-Code
From: =?ISO-8859-1?Q?Thomas_L=F8cke?= <thomas@12boo.net>
\end_layout

\begin_layout Standard
So bear in mind that it is your responsibility to encode that data as you
 need, and then set the 
\emph on
Character_Set
\emph default
 parameters accordingly.
\end_layout

\begin_layout Standard
The 
\emph on
Recipient_Kind
\emph default
 type define the kind of recipient that is being added to an email.
 If you've worked with email, these three should be familiar to you:
\end_layout

\begin_layout Enumerate
Bcc
\end_layout

\begin_layout Enumerate
Cc
\end_layout

\begin_layout Enumerate
To
\end_layout

\begin_layout Standard
When adding recipients to an email 
\emph on
Structure
\emph default
 the default is To, but since not all recipients are equal, you have the
 
\end_layout

\begin_layout Standard
The 
\emph on
Structure
\emph default
 type is at the core of it all.
 You declare an object to be of the 
\emph on
Structure
\emph default
 type, and then you use the 
\emph on
Yolk.Email.Composer
\emph default
 facilities to build and send the email.
\end_layout

\begin_layout Section
Yolk.Email.Composer
\end_layout

\begin_layout Standard
The actual tools for building and sending an email is found in this package.
 Here are tools for building emails from the ground up and there are a few
 convenience procedures if you just need to send a simple email with no
 bells or whistles.
\end_layout

\begin_layout Standard
I'm not going to go through ever procedure in this package, instead I'll
 show an example on how to build an email from the ground up and how to
 use one of the convenience procedures.
\end_layout

\begin_layout Subsection
Building and sending an email, the easy way
\end_layout

\begin_layout Standard
There are two convenience procedures in 
\emph on
Yolk.Email.Composer
\emph default
 for sending emails without having to do a whole lot of work/thinking.
 They are both named 
\emph on
Send
\emph default
 and they both look like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

procedure Send      
\end_layout

\begin_layout Plain Layout

  (ES             : in out Structure;       
\end_layout

\begin_layout Plain Layout

   From_Address   : in     String;       
\end_layout

\begin_layout Plain Layout

   From_Name      : in     String := "";       
\end_layout

\begin_layout Plain Layout

   To_Address     : in     String;       
\end_layout

\begin_layout Plain Layout

   To_Name        : in     String := "";       
\end_layout

\begin_layout Plain Layout

   Subject        : in     String;       
\end_layout

\begin_layout Plain Layout

   Text_Part      : in     String;       
\end_layout

\begin_layout Plain Layout

   SMTP_Server    : in     String := "localhost";       
\end_layout

\begin_layout Plain Layout

   SMTP_Port      : in     Positive := 25;       
\end_layout

\begin_layout Plain Layout

   Charset        : in     Character_Set := US_ASCII);    
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

procedure Send      
\end_layout

\begin_layout Plain Layout

  (ES             : in out Structure;       
\end_layout

\begin_layout Plain Layout

   From_Address   : in     String;       
\end_layout

\begin_layout Plain Layout

   From_Name      : in     String := "";       
\end_layout

\begin_layout Plain Layout

   To_Address     : in     String;       
\end_layout

\begin_layout Plain Layout

   To_Name        : in     String := "";       
\end_layout

\begin_layout Plain Layout

   Subject        : in     String;       
\end_layout

\begin_layout Plain Layout

   Text_Part      : in     String;       
\end_layout

\begin_layout Plain Layout

   HTML_Part      : in     String;       
\end_layout

\begin_layout Plain Layout

   SMTP_Server    : in     String := "localhost";       
\end_layout

\begin_layout Plain Layout

   SMTP_Port      : in     Positive := 25;       
\end_layout

\begin_layout Plain Layout

   Charset        : in     Character_Set := US_ASCII);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, the only difference between these two is that the first
 one sends plain text emails, while the second one sends 
\emph on
multipart/alternative
\emph default
 with both plain text and HTML parts.
 Usage is as simple as:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   use Yolk.Email;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Email : Structure;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   Composer.Send (ES           => Email,
\end_layout

\begin_layout Plain Layout

                  From_Address => "thomas@12boo.net",
\end_layout

\begin_layout Plain Layout

                  From_Name    => "Thomas Lcke",
\end_layout

\begin_layout Plain Layout

                  To_Address   => "tl@ada-dk.org",
\end_layout

\begin_layout Plain Layout

                  To_Name      => "Me",
\end_layout

\begin_layout Plain Layout

                  Subject      => "Is this thing on?",
\end_layout

\begin_layout Plain Layout

                  Text_Part    => "Hey you!",
\end_layout

\begin_layout Plain Layout

                  Charset      => ISO_8859_1);
\end_layout

\begin_layout Plain Layout

               
\end_layout

\begin_layout Plain Layout

   if Composer.Is_Send (Email) then
\end_layout

\begin_layout Plain Layout

      --  Success!               
\end_layout

\begin_layout Plain Layout

   else                   
\end_layout

\begin_layout Plain Layout

      --  Failure!
\end_layout

\begin_layout Plain Layout

   end if;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is possible, and allowed, to call some of the various other procedures
 prior to calling one of these.
 If for example you want to add a custom header, it can be done like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   use Yolk.Email;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Email : Structure;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   Composer.Add_Custom_Header (ES      => Email,
\end_layout

\begin_layout Plain Layout

                               Name    => "User-Agent",
\end_layout

\begin_layout Plain Layout

                               Value   => "My User Agent");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Composer.Send (ES           => Email,
\end_layout

\begin_layout Plain Layout

                  From_Address => "thomas@12boo.net",
\end_layout

\begin_layout Plain Layout

                  From_Name    => "Thomas Lcke",
\end_layout

\begin_layout Plain Layout

                  To_Address   => "tl@ada-dk.org",
\end_layout

\begin_layout Plain Layout

                  To_Name      => "Me",
\end_layout

\begin_layout Plain Layout

                  Subject      => "Is this thing on?",
\end_layout

\begin_layout Plain Layout

                  Text_Part    => "Hey you!",
\end_layout

\begin_layout Plain Layout

                  Charset      => ISO_8859_1);
\end_layout

\begin_layout Plain Layout

               
\end_layout

\begin_layout Plain Layout

   if Composer.Is_Send (Email) then
\end_layout

\begin_layout Plain Layout

      --  Success!               
\end_layout

\begin_layout Plain Layout

   else                   
\end_layout

\begin_layout Plain Layout

      --  Failure!
\end_layout

\begin_layout Plain Layout

   end if;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
And with that, the header 
\emph on
User-Agent:
\emph default
 is now added to the email:
\end_layout

\begin_layout LyX-Code
User-Agent: My User Agent
\end_layout

\begin_layout Standard
It hardly gets any easier than that.
 Lets move on and see how the above is accomplished the hard way.
\end_layout

\begin_layout Subsection
Building and sending email, the hard way
\end_layout

\begin_layout Standard
It is possible to build an email from the ground up, which obviously allows
 for a more fine grained control over what is added.
 It is also a bit more complicated, but not much.
 Lets try and mimick the easy examples, the 
\begin_inset Quotes eld
\end_inset

hard
\begin_inset Quotes erd
\end_inset

 way:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   use Yolk.Email;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Email : Structure;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   Composer.Add_Custom_Header (ES      => Email,
\end_layout

\begin_layout Plain Layout

                               Name    => "User-Agent",
\end_layout

\begin_layout Plain Layout

                               Value   => "My User Agent");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Composer.Add_From (ES      => Email,
\end_layout

\begin_layout Plain Layout

                      Address => "thomas@12boo.net",
\end_layout

\begin_layout Plain Layout

                      Name    => "Thomas Lcke",
\end_layout

\begin_layout Plain Layout

                      Charset => ISO_8859_1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Composer.Add_Recipient (ES      => Email,
\end_layout

\begin_layout Plain Layout

                           Address => "tl@ada-dk.org",
\end_layout

\begin_layout Plain Layout

                           Name    => "Me");
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

   Composer.Set_Subject (ES      => Email,
\end_layout

\begin_layout Plain Layout

                         Subject => "Is this thing on?");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Composer.Set_Text_Part (ES => Email,
\end_layout

\begin_layout Plain Layout

                           Part => "Hey you!");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Composer.Add_SMTP_Server (ES   => Email,
\end_layout

\begin_layout Plain Layout

                             Host => "localhost");
\end_layout

\begin_layout Plain Layout

                           
\end_layout

\begin_layout Plain Layout

   Composer.Send (ES => Email);
\end_layout

\begin_layout Plain Layout

               
\end_layout

\begin_layout Plain Layout

   if Composer.Is_Send (Email) then
\end_layout

\begin_layout Plain Layout

      --  Success!               
\end_layout

\begin_layout Plain Layout

   else                   
\end_layout

\begin_layout Plain Layout

      --  Failure!
\end_layout

\begin_layout Plain Layout

   end if;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Harder yes, but really not all that much more difficult.
\end_layout

\begin_layout Section
Yolk.Handlers
\end_layout

\begin_layout Standard
Most web applications will need to handle various static content, such as
 PNG, HTML and CSS files.
 
\emph on
Yolk.Handlers
\emph default
 helps you accomplish that, so you don't have to build your own handlers
 for these kinds of files.
\end_layout

\begin_layout Standard
The following filetypes are supported by 
\emph on
Yolk.Handlers
\emph default
:
\end_layout

\begin_layout Itemize
CSS
\end_layout

\begin_layout Itemize
GIF
\end_layout

\begin_layout Itemize
HTML
\end_layout

\begin_layout Itemize
ICO
\end_layout

\begin_layout Itemize
JPG
\end_layout

\begin_layout Itemize
JS
\end_layout

\begin_layout Itemize
PNG
\end_layout

\begin_layout Itemize
SVG
\end_layout

\begin_layout Itemize
XML
\end_layout

\begin_layout Itemize
XSL
\end_layout

\begin_layout Standard
The filetypes that are textual, are compressed according to the 
\emph on
Yolk.Configuration
\emph default
 setting 
\emph on
Compress_Static_Content
\emph default
 parameter, and the various regular expressions for identifying these filetypes
 are also defined in 
\emph on
Yolk.Configuration
\emph default
 by the 
\emph on
Handler_*
\emph default
 parameters.
 These regular expressions are registered by the 
\emph on
AWS.Services.Dispatchers.URI.Register_Regexp
\emph default
 procedure.
\end_layout

\begin_layout Standard
There's only one procedure in the 
\emph on
Yolk.Handlers
\emph default
 package:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

procedure Set (RH : out AWS.Services.Dispatchers.URI.Handler);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can see an example on how this is used in the demo file 
\emph on
my_handlers.adb
\emph default
.
 There's really very little reason not to use this package for handling
 of static content, but it is of course not mandatory.
\end_layout

\begin_layout Section
Yolk.Log_File_Cleanup
\end_layout

\begin_layout Standard
House-keeping is, in my humble opinion, a rather important task, and when
 dealing with HTTP servers, one of those tasks involve keeping an eye on
 the ever growing amount of log files.
 To help automate this task we have the 
\emph on
Yolk.Log_File_Cleanup
\emph default
 package.
 This package contains one procedure:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

procedure Clean_Up      
\end_layout

\begin_layout Plain Layout

  (Config_Object           : in AWS.Config.Object;       
\end_layout

\begin_layout Plain Layout

   Web_Server              : in AWS.Server.HTTP;
\end_layout

\begin_layout Plain Layout

   Amount_Of_Files_To_Keep : in Positive);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whenever the 
\emph on
Clean_Up
\emph default
 procedure is called, the 
\emph on
Log_File_Directory
\emph default
 is traversed and if more log files than 
\emph on
Amount_Of_Files_To_Keep
\emph default
 is found, then the oldest of these are deleted until the amount equals
 
\emph on
Amount_Of_Files_To_Keep
\emph default
.
\end_layout

\begin_layout Standard
In the demo file 
\emph on
demo/src/yolk_demo.adb
\emph default
 there's an example on how to call this procedure using a task that wakes
 up according to the configuration setting 
\emph on
Log_File_Cleanup_Interval
\emph default
.
\end_layout

\begin_layout Section
Yolk.Not_Found
\end_layout

\begin_layout Standard
This job of this package is to return a HTTP 404 status code and an accompanying
 simple not found HTML page.
 It's sole function 
\emph on
Generate
\emph default
 is about as simple as they come:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

function Generate      
\end_layout

\begin_layout Plain Layout

  (Request : in AWS.Status.Data)       
\end_layout

\begin_layout Plain Layout

   return AWS.Response.Data;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It relies on the template file 
\emph on
demo/exe/templates/system/404.tmpl
\emph default
 to generate the generic 404 HTML page, so if you want to use 
\emph on
Yolk.Not_Found
\emph default
 in your own application, then remember to bring along this file.
 Where the 
\emph on
404.tmpl
\emph default
 is placed is defined in the configuration parameter 
\emph on
System_Templates_Path
\emph default
.
\end_layout

\begin_layout Standard
Also worth noting is that the 
\emph on
Yolk.Not_Found.Generate
\emph default
 function is used as the default callback in the demo application.
 This means that all requested resources that doesn't match a registered
 dispatcher, is served by 
\emph on
Yolk.Not_Found.Generate
\emph default
 ie.
 a 404 is returned.
 See the 
\emph on
demo/src/my_handlers.adb
\emph default
 file for more information.
\end_layout

\begin_layout Section
Yolk.Process_Control
\end_layout

\begin_layout Standard
With 
\emph on
Yolk.Process_Control
\emph default
 you get the ability to control your application using the SIGINT, SIGPWR
 and SIGTERM signals.
 You also get a PID file placed next to your executable, which coupled with
 the 
\emph on
demo/tools/rc.yolk
\emph default
 script gives you a rather nice and simple way of starting and stopping
 your application.
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
These are:
\end_layout

\begin_layout Itemize

\emph on
Cannot_Create_PID_File
\emph default
.
 Is raised if the PID file cannot be created, eg.
 if the application lacks permissions to write to the directory where the
 executable is located.
\end_layout

\begin_layout Itemize

\emph on
Cannot_Delete_PID_File
\emph default
.
 Is raised if the PID file cannot be deleted, eg.
 if the application lacks permissions to write to the directory where the
 executable is located, or to the PID file itself.
\end_layout

\begin_layout Itemize

\emph on
PID_File_Exists
\emph default
.
 Is raised when the PID file already exists, ie.
 the application is already running or it was shutdown incorrectly.
\end_layout

\begin_layout Subsection
Using Yolk.Process_Control
\end_layout

\begin_layout Standard
When you use the 
\emph on
Yolk.Process_Control
\emph default
 package the 
\emph on
Unreserve_All_Interrupts
\emph default
 pragma is used.
 This means that depending on the compiler used one or more interrupt signals
 may be affected.
 In the case of the GNAT compiler, this is specifically mentioned in the
 source of the 
\emph on
Ada.Interrupts.Names
\emph default
 package:
\end_layout

\begin_layout Quote
-- The pragma Unreserve_All_Interrupts affects the following signal(s):
\end_layout

\begin_layout Quote
-- SIGINT: made available for Ada handler
\end_layout

\begin_layout Standard
Since neither SIGPWR or SIGTERM are reserved by the compiler, the 
\emph on
Yolk.Process_Control
\emph default
 package is able to assume control of these signals.
 You can read more about the 
\begin_inset CommandInset href
LatexCommand href
name "pragma Unreserve_All_Interrupts here"
target "http://gcc.gnu.org/onlinedocs/gnat_rm/Pragma-Unreserve_005fAll_005fInterrupts.html"

\end_inset

.
 If you compile Yolk with a different compiler than GNAT, then please check
 if one of the affected signals are reserved.
\end_layout

\begin_layout Standard
There are two procedures in the 
\emph on
Yolk.Process_Control
\emph default
 package:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

procedure Stop;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure Wait;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When you call the 
\emph on
Wait
\emph default
 procedure, you basically enter an endless loop that doesn't stop until
\end_layout

\begin_layout Enumerate
The 
\emph on
Stop
\emph default
 procedure is called
\end_layout

\begin_layout Enumerate
The application receives a SIGINT, SIGPWR or SIGTERM signal
\end_layout

\begin_layout Standard
This is quite handy for applications, that need some sort of loop to keep
 them from terminating.
 You can see an example on how this can be done in the 
\emph on
demo/src/yolk_demo.adb
\emph default
 file.
\end_layout

\begin_layout Standard
When 
\emph on
Wait
\emph default
 is called, subsequent calls to 
\emph on
Wait
\emph default
 are ignored, unless a call to 
\emph on
Stop
\emph default
 has been made or the application has received one of the SIGINT, SIGPWR
 or SIGTERM signals.
 So it's perfectly valid to do:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

Wait;
\end_layout

\begin_layout Plain Layout

--  Stop called from somewhere in the app
\end_layout

\begin_layout Plain Layout

--  Do something...
\end_layout

\begin_layout Plain Layout

Wait;
\end_layout

\begin_layout Plain Layout

--  The app receives a SIGINT signal
\end_layout

\begin_layout Plain Layout

--  Do something...
\end_layout

\begin_layout Plain Layout

Wait;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whether or not this is actually useful I don't know, but it is possible.
\end_layout

\begin_layout Section
Yolk.Process_Owner
\end_layout

\begin_layout Standard
When it is necessary to change the owner of a process, the 
\emph on
Yolk.Process_Owner
\emph default
 package is the solution.
 Obviously this can also be done when starting the application, using various
 shell tricks, but I find it it much cleaner to just let the application
 handle it by itself.
\end_layout

\begin_layout Subsection
Exceptions
\end_layout

\begin_layout Standard
There's only one:
\end_layout

\begin_layout Enumerate

\emph on
Username_Does_Not_Exist
\emph default
.
 This is raised if the given username doesn't exist on the system.
\end_layout

\begin_layout Subsection
Using Yolk.Process_Owner
\end_layout

\begin_layout Standard
There's only a single procedure in this package and its specification looks
 like this:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

procedure Set_User      
\end_layout

\begin_layout Plain Layout

  (Username : in String);    
\end_layout

\begin_layout Plain Layout

  --  Set the process owner to Username.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please note that when changing the user ID of the application with 
\emph on
Set_User
\emph default
, the group ID is changed to the first group the given user is a member
 of.
\end_layout

\begin_layout Standard
Usage is as simple as expected:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   Set_User (Username => "billybob");
\end_layout

\begin_layout Plain Layout

exception
\end_layout

\begin_layout Plain Layout

   when Username_Does_Not_Exist =>
\end_layout

\begin_layout Plain Layout

      --  User is missing.
 Do something!
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the file 
\emph on
demo/src/yolk_demo.adb
\emph default
 you'll find that 
\emph on
Yolk.Process_Owner.Set_User
\emph default
 is used in conjunction with the 
\emph on
Yolk.Configuration.Yolk_User
\emph default
 parameter.
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
