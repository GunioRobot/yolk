%% LyX 2.0.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2cm,bmargin=2cm,lmargin=2cm,rmargin=2cm}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{babel}
\usepackage[unicode=true]
 {hyperref}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxcode}
{\par\begin{list}{}{
\setlength{\rightmargin}{\leftmargin}
\setlength{\listparindent}{0pt}% needed for AMS classes
\raggedright
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\normalfont\ttfamily}%
 \item[]}
{\end{list}}

\makeatother

\begin{document}

\title{Yolk Manual}


\date{Revised October 26th. 2011}

\maketitle
\newpage{}

\tableofcontents{}

\newpage{}


\part{General Information}


\section{What is Yolk?}

Yolk is a collection of packages that aim to help build solid web-applications
using Ada. Yolk itself doesn't do a whole lot that can't be accomplished
simply by using \href{http://libre.adacore.com/libre/tools/aws/}{AWS}
and the \href{http://libre.adacore.com/libre/tools/gnat-component-collection/}{GNAT Component Collection (GNATcoll)},
but it does make the job of building complete web-applications a bit
simpler. Things like changing user for the running application, accessing
multiple databases, automatically cleaning up log files, adding basic
static content handlers and building Atom syndication XML are all
handled by Yolk.

A Yolk application is in reality an AWS application, with some sugar
added, so you're not really building a Yolk web-application, as much
as you're building an AWS web-application. What I'm getting at, is
that you need to understand how to use AWS, in order for Yolk to make
any kind of sense. What you get when using Yolk is the little things
that AWS does not readily provide.


\subsection{The Yolk demo application}

Reading this manual will of course (I hope!) help you understand how
to use Yolk, but please consider taking a closer look at the Yolk
demo application to get a feel for how Yolk is actually used. The
demo is heavily commented, so it should be fairly easy to understand
what's going on. The demo application is also very suitable as a foundation
for other AWS/Yolk applications.

It is much easier to show how to use Yolk, than it is to write down
all possible usage scenarios. With the combination of this manual,
the Yolk source files and the demo application, you should be able
to make full use of the Yolk packages in your own applications.


\subsection{The source code}

The Yolk source code is the best documentation there is. This document
is never going to be as comprehensive as the actual source, so I'll
strongly suggest having the source code available as you read this
document. What you will find in this document are short descriptions
of what a package is meant to do and perhaps small usage examples,
not a complete rundown of every type and procedure in a package.


\subsection{Building and installing Yolk}

See the README and INSTALL files. These are found in the Yolk root
directory.


\subsection{The files Yolk depend upon}

When you read this document and the Yolk source code, you'll notice
that quite a few packages depend on various files being available
at specified locations. This is for example the case with the \emph{Yolk.Configuration}
package, that must have a \emph{config.ini} file available in the
\emph{configuration/} directory, or the \emph{Yolk.Whoops} package
that expects its template file to be found at the path \emph{templates/system/500.tmpl}

All such {}``dependencies'' will of course be noted accordingly
as we go along, but instead of forgetting one or more in your own
application, I'd much rather encourage using the demo application
as a foundation for your own applications, since all these fixed paths
and files has been properly added to the demo.

I also recommend compiling and running the demo, to make sure your
Yolk install is working as intended. Just read the \emph{demo/README}
and \emph{demo/INSTALL} files for instructions on how to get it up
and running.


\subsection{The Yolk packages naming}

The Yolk packages are pretty diverse, ranging from process control
to sending email. I've tried naming them as sensibly as possible,
in the hope that the package names alone give away their function.
If I've failed, well, you're just going to have to refer to this document
or take a look at the source for yourself.

\newpage{}


\part{The Yolk Packages}


\section{Yolk}

The Yolk main package currently only contain one thing: The Yolk \emph{Version}
string. This is used in a few places, for example in the \emph{directory.tmpl}
template file, but obviously it's not something that's of vital importance
to most applications.


\section{Yolk.Cache.Discrete\_Keys}

If a piece of data doesn't change very often and it is expensive to
build, then caching it might be worthwhile. Instead of going to file/database
on every hit, you simply go to the cache and grab the latest version
from there. This is \textbf{\emph{very}} fast, at the cost of some
memory.

If you know exactly what you want to cache, the \emph{Yolk.Cache.Discrete\_Keys}
package might be just what you need.


\subsection{The generic formal parameters}

These are:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
generic
   type Key_Type is (<>);
   type Element_Type is private;
   Max_Element_Age : Duration := 3600.0;
package Yolk.Cache.Discrete_Keys is
...
\end{lstlisting}
%
\end{minipage}

The \emph{Max\_Element\_Age} defaults to one hour. You should obviously
set this to whatever suits your needs. This timer is used for all
content in the cache. You cannot set this individually for each element.


\subsection{Instantiation}

If for example we have two different sets of data (Foo and Bar) that
are expensive to build, we can instantiate a \emph{Discrete\_Keys}
package to handle this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
type Cache_Keys is (Foo, Bar);
package My_Cache is new Yolk.Cache.Discrete_Keys
  (Key_Type     => Cache_Keys,
   Element_Type => Unbounded_String);
\end{lstlisting}
%
\end{minipage}

And that is all. We now have a \emph{My\_Cache} object that can hold
two objects: \emph{Foo} and \emph{Bar}. These are of the type \emph{Unbounded\_String}
and they have a \emph{Max\_Element\_Age} of 3600.0 seconds.


\subsection{Writing to the cache}

Before we can read something from the cache, we must first write something
to it:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   Foo_Value : Unbounded_String := To_Unbounded_String ("Foo");
begin
   My_Cache.Write (Key   => Foo,
                   Value => Foo_Value);
end;
\end{lstlisting}
%
\end{minipage}

That is all it takes: {}``Foo'' is now safely tucked away in the
\emph{My\_Cache} object, and will be so for 3600.0 seconds. Calling
\emph{Write} with the \emph{Foo }key will always overwrite earlier
written \emph{Foo} elements, no matter their age.


\subsection{Reading from the cache}

A cache obviously only makes sense if you intend to read from it.
In our case we want to get our hands on the previously written {}``Foo''
value:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   Valid : Boolean := False;
   Value : Unbounded_String;
begin
   My_Cache.Read (Key      => Foo,
                  Is_Valid => Valid,
                  Value    => Value);
   if Valid then
      --  do something interesting with the data
   else
      --  the Foo data is invalid.
   end if;
end;
\end{lstlisting}
%
\end{minipage}

In order for an element to be valid (the\emph{ Is\_Valid} parameter
is true), it must:
\begin{enumerate}
\item have been added to the cache in the first place
\item be younger than \emph{Max\_Element\_Age}
\end{enumerate}
If \emph{Is\_Valid} is \emph{False}, then \emph{Value} contains undefined
garbage.


\subsection{Checking if a key is valid}

If you need to check whether a specific key exists in the cache and
is valid, then you need to use the \emph{Is\_Valid} function.

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if My_Cache.Is_Valid (Foo) then
   --  Foo is good!
else
   --  Foo is bad!
end if;
\end{lstlisting}
%
\end{minipage}

This follows the same rules as the \emph{Is\_Valid} parameter for
the \emph{Read} procedure.


\subsection{Clearing keys and the entire cache}

For clearing of keys and the entire cache we have, naturally, two
\emph{Clear} procedures:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
-- First we clear the Foo key
My_Cache.Clear (Key => Foo);

--  And then we clear the entire cache
My_Cache.Clear;
\end{lstlisting}
%
\end{minipage}

And that's all it takes.


\section{Yolk.Cache.String\_Keys}

This package is almost similar to the \emph{Yolk.Cache.Discrete\_Keys}
package. The biggest difference is that where the \emph{Discrete\_Keys}
cache package requires that you define a type for the keys, this packages
takes a regular \emph{String} as key.

The implications of this difference between the two cache packages
are subtle. Both have the same \emph{Read}, \emph{Write}, \emph{Is\_Valid}
and \emph{Clear} procedures and functions, so in that sense the two
packages are the same. The biggest difference lies in the available
generic formal parameters and the addition of the \emph{Cleanup} procedure
and the \emph{Length} function.


\subsection{The generic formal parameters}

These are:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
generic
   type Element_Type is private;
   Cleanup_Size      : Positive := 200;
   Cleanup_On_Write  : Boolean  := True;
   Max_Element_Age   : Duration := 3600.0;
   Reserved_Capacity : Positive := 100;
package Yolk.Cache.Discrete_Keys is
...
\end{lstlisting}
%
\end{minipage}

When the amount of elements in the cache >= \emph{Cleanup\_Size},
then the \emph{Cleanup} procedure is called by \emph{Write}, if \emph{Cleanup\_On\_Write}
is set to Boolean \emph{True}. \emph{Cleanup\_Size} is a sort of failsafe
for this cache package. Since we can't know for sure what is being
added (we don't know the keys beforehand), we need to make sure it
doesn't gobble up all available resources. Set this number high enough
that it'll never tricker under normal circumstances, but low enough
that it'll prevent resource exhaustion in case of errors.

The \emph{Max\_Element\_Age} defaults to one hour. You should obviously
set this to whatever suits your needs. This timer is used for all
content in the cache. You cannot set this individually for each element.

\emph{Reserved\_Capacity} should be set as close as possible to the
expected final size of the cache. If your best guestimate is 200 elements
in the cache, then set this to 200. Note that this setting has no
bearing has no bearing on the actual size of the cache. The cache
will happily grow beyond the \emph{Reserved\_Capacity} value.


\subsection{Instantiation}

Instantiating \emph{String\_Keys} is done like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
package My_Cache is new Yolk.Cache.String_Keys
  (Element_Type      => Unbounded_String,
   Reserved_Capacity => 200);
\end{lstlisting}
%
\end{minipage}

And that is all. We now have a \emph{My\_Cache} object that can hold
200 objects of the type \emph{Unbounded\_String}, all of which have
a \emph{Max\_Element\_Age} of 3600.0 seconds. 


\subsection{Writing to the cache}

Before we can read something from the cache, we must first write something
to it:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   Value : Unbounded_String := To_Unbounded_String ("42");
begin
   My_Cache.Write (Key   => "Foo",
                   Value => Value);
end;
\end{lstlisting}
%
\end{minipage}

That is all it takes: {}``42'' is now safely tucked away in the
\emph{My\_Cache} object under the key {}``Foo'', and will be so
for 3600.0 seconds. Calling \emph{Write} with the {}``Foo''\emph{
}String will always overwrite earlier written {}``Foo'' elements,
no matter their age.


\subsection{Reading from the cache}

A cache obviously only makes sense if you intend to read from it.
In our case we want to get our hands on the previously written {}``Foo''
value:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   Valid : Boolean := False;
   Value : Unbounded_String;
begin
   My_Cache.Read (Key      => "Foo",
                  Is_Valid => Valid,
                  Value    => Value);
   if Valid then
      --  do something interesting with the data
   else
      --  the Foo data is invalid.
   end if;
end;
\end{lstlisting}
%
\end{minipage}

In order for an element to be valid (the\emph{ Is\_Valid} parameter
is true), it must:
\begin{enumerate}
\item have been added to the cache in the first place
\item be younger than \emph{Max\_Element\_Age}
\end{enumerate}
If \emph{Is\_Valid} is \emph{False}, then \emph{Value} contains undefined
garbage.


\subsection{Checking if a key is valid}

If you need to check whether a specific key exists in the cache and
is valid, then you need to use the \emph{Is\_Valid} function.

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if My_Cache.Is_Valid ("Foo") then
   --  Foo is good!
else
   --  Foo is bad!
end if;
\end{lstlisting}
%
\end{minipage}

This follows the same rules as the \emph{Is\_Valid} parameter for
the \emph{Read} procedure.


\subsection{Clearing keys and the entire cache}

For clearing of keys and the entire cache we have, naturally, two
\emph{Clear} procedures:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
-- First we clear the Foo key
My_Cache.Clear (Key => "Foo");

--  And then we clear the entire cache
My_Cache.Clear;
\end{lstlisting}
%
\end{minipage}

And that's all it takes.


\subsection{How much is in there?}

With the \emph{Discrete\_Keys} cache we obviously always now the exact
amount of keys available, since we've defined the keys ourselves.
This is not the case with the \emph{String\_Keys} cache, where any
String can be a key. If we need to know how many elements that are
currently in the cache, we call the \emph{Length} function:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if My_Cache.Length > 1000 then
   --  Woa! Lots of stuff in the cache..
end if;
\end{lstlisting}
%
\end{minipage}

Note that \emph{Length} count both valid and invalid elements.


\subsection{Cleanup - Keeping cache size in check}

if \emph{Cleanup\_On\_Write} is \emph{True}, then \emph{Cleanup} is
called by \emph{Write }whenever the size of the cache reach \emph{Cleanup\_Size}.
It is of course also possible to call it manually:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if My_Cache.Length > 1000 then
   My_Cache.Cleanup;
end if;
\end{lstlisting}
%
\end{minipage}

If you've set \emph{Cleanup\_On\_Write} to Boolean \emph{False} and
the String keys are coming from outside sources, then you really should
make sure you call \emph{Cleanup} on a regular basis. 


\section{Yolk.Config\_File\_Parser}

This package enable you to access KEY/VALUE pairs in configuration
files that are written in the style:
\begin{lyxcode}
\#~This~is~a~comment

-{}-~This~is~also~a~comment

KEY~VALUE
\end{lyxcode}
Keys are case-insensitive, so \emph{FOO}, \emph{foo} and \emph{fOo}
are all the same.\emph{ }Blank lines and comments are ignored and
so is pre/postfixed whitespace. It is not necessary to quote values
that contain whitespace, to this:
\begin{lyxcode}
KEY~some~value~with~whitespace
\end{lyxcode}
is perfectly valid, and will return {}``\emph{some value with whitespace}''
when calling \emph{Get (KEY)}. If VALUE is Boolean True or False (case-insensitive),
then the KEY can be returned as a String or a Boolean, depending on
the target type. If the target type does not match the VALUE and no
sensible conversion can be made, then a \emph{Conversion\_Error} exception
is raised. No dummy values are returned at any time.

To clear a default value, simply add the key to the configuration
file, with no value set.


\subsection{The generic formal parameters}

These are:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
generic
   use Ada.Strings.Unbounded;
   type Key_Type is (<>);
   type Defaults_Array_Type is array (Key_Type) of Unbounded_String;
   Defaults    : in Defaults_Array_Type;    
   Config_File : in String := "configuration/config.ini";
package Yolk.Config_File_Parser is
...
\end{lstlisting}
%
\end{minipage}

Note that the \emph{Config\_File} parameter has a default value. This
path is actually where Yolk expects to find the configuration file
used by the Yolk.Configuration package.


\subsection{Exceptions}

There are 3 different exceptions that can be raised by the \emph{Yolk.Config\_File\_Parser}
package. These are:
\begin{itemize}
\item \emph{Unknown\_Key}. This is raised if an unknown key has been found
in the configuration file given when instantiating the package or
when \emph{Load\_File} is called.
\item \emph{Cannot\_Open\_Config\_File}. This is raised when a configuration
file cannot be read.
\item \emph{Conversion\_Error}. This is raised when a value cannot be converted
to the target type, ie. the value {}``42'' to a Boolean.
\end{itemize}

\subsection{Instantiation}

\emph{Yolk.Config\_File\_Parser} is a generic package, so in order
to use it, you have to instantiate it, like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
package My_Configuration is

   type Keys is (Foo, Bar);
   type Defaults_Array is array (Keys) of
     Ada.Strings.Unbounded.Unbounded_String;

   Default_Values : constant Defaults_Array :=
                      (Foo => TUS ("some foo"),
                       Bar => TUS ("some bar"));
   --  TUS is a rename of the To_Unbounded_String function. It
   --  is found in the Yolk.Utilities package.

   package Config is new Yolk.Config_File_Parser
     (Key_Type => Keys,
      Defaults_Array_Type => Defaults_Array,
      Defaults => Default_Value,
      Config_File => "config.ini");

end My_Configuration;
\end{lstlisting}
%
\end{minipage}

Here we instantiate the \emph{Config} package with \emph{config.ini}
as the configuration file. This means that KEY/VALUE pairs found in
this file will overwrite the default values set in the \emph{Default\_Values}
array. Setting a default value to \emph{Null\_Unbounded\_String} means
the value is empty.


\subsection{Re-loading configuration files}

With the \emph{Load\_File} procedure you can re-load a new configuration
file into your \emph{Config} package:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
My_Configuration.Config.Load_File ("new_config.ini");
\end{lstlisting}
%
\end{minipage}

And that is all. Now the KEY/VALUE pairs of \emph{new\_config.ini}
will overwrite the ones originally found in the \emph{config.ini}
file the package was instantiated with. You can do this as many times
as you like. Note that you cannot change what KEY's are valid, so
if the \emph{new\_config.ini} file contains unknown keys, \emph{Load\_File}
will raise the \emph{Unknown\_Key} exception.


\subsection{Getting values}

With instantiation and loading of configuration files out of the way,
it is now time to get to the configuration values. To get the value
of the \emph{Foo} key, you do:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
My_Configuration.Config.Get (Foo);
\end{lstlisting}
%
\end{minipage}

There are Get functions for the following types:
\begin{itemize}
\item Boolean
\item Duration
\item Float
\item Integer
\item String
\item Unbounded\_String
\end{itemize}
Empty keys simply return an empty String or a \emph{Null\_Unbounded\_String},
depending on the target type. If a key is empty and the target type
is not a String or an Unbounded\_String, then the \emph{Conversion\_Error}
exception is raised.


\subsection{Checking if a KEY has a VALUE}

You can check if a key has a value with the \emph{Has\_Value} function:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if Has_Value (Foo) then
   Put_Line ("Foo has a value");
end if;
\end{lstlisting}
%
\end{minipage}

Basically all this function does is return Boolean True if the value
of the given key is not a \emph{Null\_Unbounded\_String}.


\section{Yolk.Configuration}

This package is a bit of an oddball, as all it does is instantiate
the \emph{Yolk.Config\_File\_Parser} generic with the default AWS
and Yolk configuration values. This is used by Yolk internally, but
also possibly by the AWS component of your application. The instantiation
looks like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
package Config is new Config_File_Parser
  (Key_Type => Keys,
   Defaults_Array_Type => Defaults_Array,
   Defaults => Default_Values,
   Config_File => "configuration/config.ini");
\end{lstlisting}
%
\end{minipage}

As you can see, it is required that there's a configuration file found
in \emph{configuration/config.ini}. This path is of course relative
to the application. There's a fully commented \emph{config.ini} file
available in \emph{demo/exe/configuration/}. This setup is required
if you're using Yolk, and the only way to avoid having \emph{config.ini}
in the mentioned directory is if you manually change the path in the
source file before compiling Yolk.

I recommend taking a look at the Yolk demo application to see how
the \emph{Yolk.Configuration} package is used.


\subsection{Get the AWS specific configuration settings}

When you start an AWS server, you need to give it an \emph{AWS.Config.Object}
with all the necessary configuration settings. This is already handled
for you in \emph{Yolk.Configuration}, all you have to do is call the
\emph{Get\_AWS\_Configuration} function, like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
AWS_Config : constant AWS.Config.Object := 
  Yolk.Configuration.Get_AWS_Configuration;
AWS.Server.Start (Web_Server => Web_Server,
                  Dispatcher => Resource_Handlers,
                  Config     => AWS_Config);
\end{lstlisting}
%
\end{minipage}

You're not forced to use this, if you don't want to. But even if you
don't, you'll still have to make a valid configuration file available
in the configuration directory defined in the \emph{Config} instantiation,
so you might as well use this as the configuration foundation for
the AWS HTTP server component of your application. Again, see the
demo application for examples on how this is done.


\section{Yolk.Connect\_To\_DB}

This is a small wrapper for the \emph{GNATCOLL.SQL} database connection
functionality. Once you've connected to the database, you use plain
\emph{GNATCOLL.SQL} tools to query/update your database. The ability
to stay connected to several databases in the same application was
what drove the development of the \emph{Yolk.Connect\_To\_DB} package,
as the \emph{GNATCOLL.SQL.Exec.Get\_Task\_Connection} function did
not support that out of the box.

At the time of writing, GNATcoll supports PostgreSQL and SQLite, but
Yolk only supports connecting to PostgreSQL. The reason for this is
simple: I don't use SQLite now and I don't plan on using it in the
future, and if I can't test something, I don't feel like adding it
to Yolk.


\subsection{The Connection\_Mapping\_Method type}

To define how AWS threads are mapped to the database connections,
you need to understand the \emph{Connection\_Mapping\_Method} type.
There are two different methods of connecting to a database:
\begin{enumerate}
\item AWS\_Tasks\_To\_DB
\item DB\_Conn\_Tasks\_To\_DB
\end{enumerate}
The first method is the simplest and it's also the method that requires
fewest resources. Using method 1. we simply map each AWS thread to
a database connection, meaning that if you have 5 AWS threads, you're
going to end up with 5 open connections to your database. Whenever
an AWS thread ask for a database connection, it always get the same
connection. If no connection has been made yet, one is started and
mapped to the AWS thread that started it.

This works flawlessly as long as you don't need to connect to more
than one database, but it fails miserably if you have more than one
database in play. For such cases we need option 2. 

When option 2. is used, one set of database connection tasks are started
for every database you connect to. So if you have an AWS server with
5 threads and you need to connect to two databases, you're going to
end up with 5 small tasks whose only purpose in life is to open and
maintain a connection to the database. These 5 \emph{DB\_Conn} tasks
are then mapped to the AWS threads using the \emph{Ada.Task\_Attributes}
package.

This also means that you can only instantiate once using \emph{AWS\_Tasks\_To\_DB}
whereas you can instantiate as many times as you like with \emph{DB\_Conn\_Tasks\_To\_DB}.
If you need to connect to several databases, make sure that the one
you use the most is setup with the \emph{AWS\_Tasks\_To\_DB} connection
mapping. This is the fastest and most resource efficient method, as
we don't have to spend time going through one of the \emph{DB\_Conn}
tasks that are necessary with the \emph{DB\_Conn\_Tasks\_To\_DB} method.


\subsection{Database credentials}

The \emph{Set\_Credentials} function is responsible for setting the
credentials necessary to connect to the database.

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
Yolk.Connect_To_DB.Set_Credentials
  (Host     => "localhost",
   Database => "some_database",
   User     => "username",
   Password => "secret");
\end{lstlisting}
%
\end{minipage}

This call return a \emph{Yolk.Connect\_To\_DB.Credentials} type which
is then used when instantiating the \emph{Yolk.Connect\_To\_DB.PostgreSQL}
generic.


\section{Yolk.Connect\_To\_DB.PostgreSQL}

When instantiated, this package provides a single function: \emph{Connection}.
This function return a \emph{GNATCOLL.SQL.Exec.Database\_Connection}
type, which is then used to interact with your database.


\subsection{The generic formal parameters}

When you're actually going to connect to your PostgreSQL database(s),
this is the package you want. It's a generic with two formal parameters:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
generic
   DB_Credentials : Credentials;
   Task_To_DB_Mapping_Method : Connection_Mapping_Method;    
package Yolk.Connect_To_DB.PostgreSQL is
   function Connection return GNATCOLL.SQL.Exec.Database_Connection;
end Yolk.Connect_To_DB.PostgreSQL;
\end{lstlisting}
%
\end{minipage}

Instantiation is pretty straightforward:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
package My_DB is new Connect_To_DB.PostgreSQL      
  (DB_Credentials            => Connect_To_DB.Set_Credentials         
     (Host     => My.Config.Get (My.DB_Host),          
      Database => My.Config.Get (My.DB_Name),          
      User     => My.Config.Get (My.DB_User),          
      Password => My.Config.Get (My.DB_Password)), 
   Task_To_DB_Mapping_Method => Connect_To_DB.AWS_Tasks_To_DB);
\end{lstlisting}
%
\end{minipage}

In this case we've used the \emph{AWS\_Tasks\_To\_DB} mapping method,
so each AWS thread will be mapped to a specific database connection.


\subsection{Connecting to the database}

With the \emph{My\_DB} package up and running, connecting to the database
is done like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
DB_Conn : constant Database_Connection := My_DB.Connection;
\end{lstlisting}
%
\end{minipage}

\noindent You can now use the \emph{DB\_Conn} connection just as if
you'd created the \emph{Database\_Connection} object using the method
described in the \href{https://www.adacore.com/wp-content/files/auto_update/gnatcoll-docs/gnatcoll.html\#Database-interface}{GNAT Component Collection (GNATcoll) manual}.
There's also a usage example in the Yolk demo. Take a look at the
\emph{View.DB\_Test} package.


\section{Yolk.Email}

Using \emph{Yolk.Email} and the child package \emph{Yolk.Email.Composer}
you can build and send more or less any kind of email:
\begin{itemize}
\item Plain text
\item Multipart/Alternative
\item Multipart/Mixed
\end{itemize}
The package supports adding multiple SMTP servers, meaning you can
add as many as you need, and the email will then be send via the first
one that accepts it.

The \emph{Yolk.Email} package define 4 exceptions and 3 types. The
facilities for actually constructing and sending the email are found
in \emph{Yolk.Email.Composer}.


\subsection{Exceptions}

These are:
\begin{itemize}
\item \emph{Attachment\_File\_Not\_Found}. Is raised if a file attachment
is not found at the given path.
\item \emph{No\_Address\_Set}. Is raised if the address component of a To,
Reply-To, From, Bcc/Cc header is missing.
\item \emph{No\_Sender\_Set\_With\_Multiple\_From}. Is raised when an email
contains multiple From headers but no Sender header, as per RFC-5322,
3.6.2. http://tools.ietf.org/html/rfc5322
\item \emph{No\_SMTP\_Host\_Set}. Is raised if the SMTP host list is empty,
ie. no SMTP host has been set for sending the email.
\end{itemize}

\subsection{The Yolk.Email types}

When using \emph{Yolk.Email.Composer} to build and send emails, three
types declared in \emph{Yolk.Email} are central:
\begin{enumerate}
\item \emph{Character\_Set}
\item \emph{Recipient\_Kind}
\item \emph{Structure}
\end{enumerate}
The \emph{Character\_Set} type define what character set is used when
data is added to an email \emph{Structure} object. For example looking
at the \emph{Yolk.Email.Composer.Add\_From} procedure, we see that
the \emph{Charset} parameter defaults to \emph{US\_ASCII}:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Add_From      
  (ES        : in out Structure;       
   Address   : in     String;       
   Name      : in     String := "";       
   Charset   : in     Character_Set := US_ASCII);
\end{lstlisting}
%
\end{minipage}

This does not mean that \emph{Yolk.Email.Composer.Add\_From} will
encode \emph{Name} as \emph{US\_ASCII}, instead it means that the
data given in \emph{Name} is already encoded as \emph{US\_ASCII}.
So if \emph{Name} had contained an ISO-8859-1 encoded String, then
the call would've looked like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   use Yolk.Email;

   Email : Structure;
begin
   Composer.Add_From      
     (ES        => Email,       
      Address   => "thomas@12boo.net",
      Name      => "Thomas Løcke",
      Charset   => ISO_8859_1);
end;
\end{lstlisting}
%
\end{minipage}

In this case you will end up with a From header looking like this:
\begin{lyxcode}
From:~=?ISO-8859-1?Q?Thomas\_L=F8cke?=~<thomas@12boo.net>
\end{lyxcode}
So bear in mind that it is your responsibility to encode that data
as you need, and then set the \emph{Character\_Set} parameters accordingly.

The \emph{Recipient\_Kind} type define the kind of recipient that
is being added to an email. If you've worked with email, these three
should be familiar to you:
\begin{enumerate}
\item Bcc
\item Cc
\item To
\end{enumerate}
When adding recipients to an email \emph{Structure} the default is
To, but since not all recipients are equal, you have the 

The \emph{Structure} type is at the core of it all. You declare an
object to be of the \emph{Structure} type, and then you use the \emph{Yolk.Email.Composer}
facilities to build and send the email.


\section{Yolk.Email.Composer}

The actual tools for building and sending an email is found in this
package. Here are tools for building emails from the ground up and
there are a few convenience procedures if you just need to send a
simple email with no bells or whistles.

I'm not going to go through ever procedure in this package, instead
I'll show an example on how to build an email from the ground up and
how to use one of the convenience procedures.


\subsection{Building and sending an email, the easy way}

There are two convenience procedures in \emph{Yolk.Email.Composer}
for sending emails without having to do a whole lot of work/thinking.
They are both named \emph{Send} and they both look like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Send      
  (ES             : in out Structure;       
   From_Address   : in     String;       
   From_Name      : in     String := "";       
   To_Address     : in     String;       
   To_Name        : in     String := "";       
   Subject        : in     String;       
   Text_Part      : in     String;       
   SMTP_Server    : in     String := "localhost";       
   SMTP_Port      : in     Positive := 25;       
   Charset        : in     Character_Set := US_ASCII);    
   
procedure Send      
  (ES             : in out Structure;       
   From_Address   : in     String;       
   From_Name      : in     String := "";       
   To_Address     : in     String;       
   To_Name        : in     String := "";       
   Subject        : in     String;       
   Text_Part      : in     String;       
   HTML_Part      : in     String;       
   SMTP_Server    : in     String := "localhost";       
   SMTP_Port      : in     Positive := 25;       
   Charset        : in     Character_Set := US_ASCII);
\end{lstlisting}
%
\end{minipage}

As you can see, the only difference between these two is that the
first one sends plain text emails, while the second one sends \emph{multipart/alternative}
with both plain text and HTML parts. Usage is as simple as:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   use Yolk.Email;

   Email : Structure;
begin
   Composer.Send (ES           => Email,
                  From_Address => "thomas@12boo.net",
                  From_Name    => "Thomas Løcke",
                  To_Address   => "tl@ada-dk.org",
                  To_Name      => "Me",
                  Subject      => "Is this thing on?",
                  Text_Part    => "Hey you!",
                  Charset      => ISO_8859_1);
               
   if Composer.Is_Send (Email) then
      --  Success!               
   else                   
      --  Failure!
   end if;
end;
\end{lstlisting}
%
\end{minipage}

It is possible, and allowed, to call some of the various other procedures
prior to calling one of these. If for example you want to add a custom
header, it can be done like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   use Yolk.Email;

   Email : Structure;
begin
   Composer.Add_Custom_Header (ES      => Email,
                               Name    => "User-Agent",
                               Value   => "My User Agent");

   Composer.Send (ES           => Email,
                  From_Address => "thomas@12boo.net",
                  From_Name    => "Thomas Løcke",
                  To_Address   => "tl@ada-dk.org",
                  To_Name      => "Me",
                  Subject      => "Is this thing on?",
                  Text_Part    => "Hey you!",
                  Charset      => ISO_8859_1);
               
   if Composer.Is_Send (Email) then
      --  Success!               
   else                   
      --  Failure!
   end if;
end;
\end{lstlisting}
%
\end{minipage}

And with that, the header \emph{User-Agent:} is now added to the email:
\begin{lyxcode}
User-Agent:~My~User~Agent
\end{lyxcode}
It hardly gets any easier than that. Lets move on and see how the
above is accomplished the hard way.


\subsection{Building and sending email, the hard way}

It is possible to build an email from the ground up, which obviously
allows for a more fine grained control over what is added. It is also
a bit more complicated, but not much. Lets try and mimick the easy
examples, the {}``hard'' way:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   use Yolk.Email;

   Email : Structure;
begin
   Composer.Add_Custom_Header (ES      => Email,
                               Name    => "User-Agent",
                               Value   => "My User Agent");

   Composer.Add_From (ES      => Email,
                      Address => "thomas@12boo.net",
                      Name    => "Thomas Løcke",
                      Charset => ISO_8859_1);

   Composer.Add_Recipient (ES      => Email,
                           Address => "tl@ada-dk.org",
                           Name    => "Me");
 
   Composer.Set_Subject (ES      => Email,
                         Subject => "Is this thing on?");

   Composer.Set_Text_Part (ES => Email,
                           Part => "Hey you!");

   Composer.Add_SMTP_Server (ES   => Email,
                             Host => "localhost");
                           
   Composer.Send (ES => Email);
               
   if Composer.Is_Send (Email) then
      --  Success!               
   else                   
      --  Failure!
   end if;
end;
\end{lstlisting}
%
\end{minipage}

Harder yes, but really not all that much more difficult.


\section{Yolk.Handlers}

Most web applications will need to handle various static content,
such as PNG, HTML and CSS files. \emph{Yolk.Handlers} helps you accomplish
that, so you don't have to build your own handlers for these kinds
of files.

The following filetypes are supported by \emph{Yolk.Handlers}:
\begin{itemize}
\item CSS
\item GIF
\item HTML
\item ICO
\item JPG
\item JS
\item PNG
\item SVG
\item XML
\item XSL
\end{itemize}
The filetypes that are textual, are compressed according to the \emph{Yolk.Configuration}
setting \emph{Compress\_Static\_Content} parameter, and the various
regular expressions for identifying these filetypes are also defined
in \emph{Yolk.Configuration} by the \emph{Handler\_{*}} parameters.
These regular expressions are registered by the \emph{AWS.Services.Dispatchers.URI.Register\_Regexp}
procedure.

There's only one procedure in the \emph{Yolk.Handlers} package:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Set (RH : out AWS.Services.Dispatchers.URI.Handler);
\end{lstlisting}
%
\end{minipage}

You can see an example on how this is used in the demo file \emph{my\_handlers.adb}.
There's really very little reason not to use this package for handling
of static content, but it is of course not mandatory.

This package makes use of the \emph{Yolk.Static\_Content} package
for the actual delivery of the content to the user.


\section{Yolk.Log\_File\_Cleanup}

House-keeping is a very important task, and when dealing with HTTP
servers, one of those tasks involve keeping an eye on the ever growing
amount of access and error log files. To help automate this task we
have the \emph{Yolk.Log\_File\_Cleanup} package. This package contains
one procedure:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Delete      
  (Config_Object           : in AWS.Config.Object;       
   Web_Server              : in AWS.Server.HTTP;
   Amount_Of_Files_To_Keep : in Positive);
\end{lstlisting}
%
\end{minipage}

Whenever the \emph{Delete} procedure is called, the directory where
AWS keeps its log files is traversed and if more log files than \emph{Amount\_Of\_Files\_To\_Keep}
is found, then the oldest of these are deleted until the amount equals
\emph{Amount\_Of\_Files\_To\_Keep}. 

Note that \emph{Yolk.Log\_File\_Cleanup} only deals with the AWS acces
and error log files. In the demo file \emph{demo/src/yolk\_demo.adb}
there's an example on how to call this procedure using a task that
wakes up according to the configuration setting \emph{Log\_File\_Cleanup\_Interval}.

Be sure to read the \emph{Logging - Rotating And Regular} section
in the \emph{demo/exe/configuration/config.ini} file for more information
on the configuration parameters that affect this system.


\section{Yolk.Not\_Found}

This job of this package is to return a HTTP 404 status code and an
accompanying simple not found HTML page. It's sole function \emph{Generate}
is about as simple as they come:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function Generate      
  (Request : in AWS.Status.Data)       
   return AWS.Response.Data;
\end{lstlisting}
%
\end{minipage}

It relies on the template file \emph{demo/exe/templates/system/404.tmpl}
to generate the generic 404 HTML page, so if you want to use \emph{Yolk.Not\_Found}
in your own application, then remember to bring along this file. Where
the \emph{404.tmpl} is placed is defined in the configuration parameter
\emph{System\_Templates\_Path}.

Also worth noting is that the \emph{Yolk.Not\_Found.Generate} function
is used as the default callback in the demo application. This means
that all requested resources that doesn't match a registered dispatcher,
is served by \emph{Yolk.Not\_Found.Generate} ie. a 404 is returned.
See the \emph{demo/src/my\_handlers.adb} file for more information.


\section{Yolk.Process\_Control}

With \emph{Yolk.Process\_Control} you get the ability to control your
application using the SIGINT, SIGPWR and SIGTERM signals. You also
get a PID file placed next to your executable, which coupled with
the \emph{demo/tools/rc.yolk} script gives you a rather nice and simple
way of starting and stopping your application.


\subsection{Exceptions}

These are:
\begin{itemize}
\item \emph{Cannot\_Create\_PID\_File}. Is raised if the PID file cannot
be created, eg. if the application lacks permissions to write to the
directory where the executable is located.
\item \emph{Cannot\_Delete\_PID\_File}. Is raised if the PID file cannot
be deleted, eg. if the application lacks permissions to write to the
directory where the executable is located, or to the PID file itself.
\item \emph{PID\_File\_Exists}. Is raised when the PID file already exists,
ie. the application is already running or it was shutdown incorrectly.
\end{itemize}

\subsection{Using Yolk.Process\_Control}

When you use the \emph{Yolk.Process\_Control} package the \emph{Unreserve\_All\_Interrupts}
pragma is used. This means that depending on the compiler used one
or more interrupt signals may be affected. In the case of the GNAT
compiler, this is specifically mentioned in the source of the \emph{Ada.Interrupts.Names}
package:
\begin{quote}
-- The pragma Unreserve\_All\_Interrupts affects the following signal(s):

-- SIGINT: made available for Ada handler
\end{quote}
Since neither SIGPWR or SIGTERM are reserved by the compiler, the
\emph{Yolk.Process\_Control} package is able to assume control of
these signals. You can read more about the \href{http://gcc.gnu.org/onlinedocs/gnat_rm/Pragma-Unreserve_005fAll_005fInterrupts.html}{pragma Unreserve\_{}All\_{}Interrupts here}.
If you compile Yolk with a different compiler than GNAT, then please
check if one of the affected signals are reserved.

There are two procedures in the \emph{Yolk.Process\_Control} package:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Stop;

procedure Wait;
\end{lstlisting}
%
\end{minipage}

When you call the \emph{Wait} procedure, you basically enter an endless
loop that doesn't stop until
\begin{enumerate}
\item The \emph{Stop} procedure is called
\item The application receives a SIGINT, SIGPWR or SIGTERM signal
\end{enumerate}
This is quite handy for applications, that need some sort of loop
to keep them from terminating. You can see an example on how this
can be done in the \emph{demo/src/yolk\_demo.adb} file.

When \emph{Wait} is called, subsequent calls to \emph{Wait} are ignored,
unless a call to \emph{Stop} has been made or the application has
received one of the SIGINT, SIGPWR or SIGTERM signals. So it's perfectly
valid to do:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
Wait;
--  Stop called from somewhere in the app
--  Do something...
Wait;
--  The app receives a SIGINT signal
--  Do something...
Wait;
\end{lstlisting}
%
\end{minipage}

Whether or not this is actually useful I don't know, but it is possible.


\section{Yolk.Process\_Owner}

When it is necessary to change the owner of a process, the \emph{Yolk.Process\_Owner}
package is the solution. Obviously this can also be done when starting
the application, using various shell tricks, but I find it it much
cleaner to just let the application handle it by itself.


\subsection{Exceptions}

There's only one:
\begin{enumerate}
\item \emph{Username\_Does\_Not\_Exist}. This is raised if the given username
doesn't exist on the system.
\end{enumerate}

\subsection{Using Yolk.Process\_Owner}

There's only a single procedure in this package and its specification
looks like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Set_User      
  (Username : in String);    
  --  Set the process owner to Username.
\end{lstlisting}
%
\end{minipage}

Please note that when changing the user ID of the application with
\emph{Set\_User}, the group ID is changed to the first group the given
user is a member of.

Usage is as simple as expected:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
begin
   Set_User (Username => "billybob");
exception
   when Username_Does_Not_Exist =>
      --  User is missing. Do something!
end;
\end{lstlisting}
%
\end{minipage}

In the file \emph{demo/src/yolk\_demo.adb} you'll find that \emph{Yolk.Process\_Owner.Set\_User}
is used in conjunction with the \emph{Yolk.Configuration.Yolk\_User}
parameter.


\section{Yolk.Rotating\_Log}

This package provides the ability to write log data to three predefined
log traces:
\begin{enumerate}
\item Error
\item Info
\item SQL
\end{enumerate}
These traces correspond with the components of the \emph{Yolk.Rotating\_Log.Trace\_Handles}
enumeration type. Data written to one of these traces are written
to files and these files are automatically rotated when they reach
a specified size. The rotation happens according to a {}``slot''
system, so you don't have to worry about cleaning away old log files
on a regular basis. The slot system works by appending a slot number
to each log file, so if you set the configuration parameter \emph{Max\_Slot\_Count}
to 3, then when starting the rotating log system you'll get a file
named \emph{Foo-rotating-INFO-1.log} for the \emph{Info} trace (if
your application is named Foo) and when that file reaches the \emph{Rotating\_Log\_Size\_Limit}
it is rotated to \emph{Foo-rotating-INFO-2.log} and so on and so forth.
When the last slot rotates, it starts all over with 1.

This system has the obvious advantage of never growing beyond a known
limited size. On the other hand it has the disadvantage of not being
very good at keeping old log data readily at hand, as everything is
going to get overwritten sooner or later.

For more information, take a look at the \emph{Logging - Rotating
And Regular} section of the \emph{demo/exe/configuration/config.ini}
file.

Note that this package handles all log data generated by the \emph{GNATCOLL.SQL}
packages. See the \emph{demo/exe/configuration/config.ini} for how
to enable/disable the different levels of SQL related log data.


\subsection{Exceptions}

These are:
\begin{itemize}
\item \emph{Cannot\_Create\_Log\_File}. Is raised when it's not possible
to create one of the rotating log files.
\item \emph{Cannot\_Write\_To\_Log\_File}. Is raised when it's not possible
to write to one of the rotating log files.
\end{itemize}

\subsection{Starting the rotating log files}

It's not enough to simply \emph{with} the package, you have to start
the rotating log system before you can actually use it. This is done
with the aptly named \emph{Start\_Rotating\_Logs} procedure:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Start_Rotating_Logs
  (Emit_Warning_If_Already_Running : Boolean := True);
\end{lstlisting}
%
\end{minipage}

Setting the \emph{Emit\_Warning\_If\_Already\_Running} to \emph{False}
will make sure that a second call to \emph{Start\_Rotating\_Logs}
won't emit a warning message on the \emph{Info} trace.


\subsection{Writing log data}

With the rotating log system started, writing data to it is a simple
matter of calling the \emph{Trace} procedure. It looks like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Trace      
  (Handle     : in Trace_Handles;       
   Log_String : in String);
\end{lstlisting}
%
\end{minipage}

It should be obvious how this procedure is used. Note that the configuration
setting \emph{Immediate\_Flush} controls whether or not the \emph{Log\_String}
is written to file immediately or if a buffer is used.


\section{Yolk.Static\_Content}

Most web applications have a lot of static content, ie. stuff that
doesn't change. Things like PNG's, HTML, CSS and Javascript. These
are content types that are common for most websites, so a application
is going to have to handle these in some way. This is where \emph{Yolk.Static\_Content}
comes in. Two kinds of files are handled by \emph{Yolk.Static\_Content}:
\begin{itemize}
\item Compressable (XML, HTML, CSS, JS and so on)
\item Non-compressable (PNG, JPG, GIF, ICO and so on)
\end{itemize}
It is up to you, the user, to decide whether a specific kind of file
is compressable or not - the package does not make any such assumptions.
The difference between the two, is that compressable files are compressed
prior to delivery, if the clients HTTP request includes a \emph{Accept-Encoding:
gzip} header. Non-compressable files are simply returned as is. For
both kinds, a generic 404 is returned if the requested file doesn't
exist.

\emph{Yolk.Static\_Content} is affected by four configuration settings:
\begin{itemize}
\item Compressed\_Cache\_Directory
\item Compressed\_Max\_Age
\item Compress\_Minimum\_File\_Size
\item WWW\_Root
\end{itemize}
You should carefully read the \emph{demo/exe/configuration/config.ini}
file for information on what exactly these do.


\subsection{The static content cache setup}

The configuration parameter \emph{Compressed\_Cache\_Directory} defines
where the compressed version of the static content is saved. When
your application is started, this directory may or may not exist,
and it may or may not contain various compressed files. To make sure
that the directory exists and is empty, you should call the \emph{Static\_Content\_Cache\_Setup}
procedure:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Static_Content_Cache_Setup      
  (Log_To_Info_Trace : in Boolean := True;       
   No_Cache          : in Boolean := False;       
   No_Store          : in Boolean := False;       
   No_Transform      : in Boolean := False;       
   Max_Age           : in AWS.Messages.Delta_Seconds := 86400;
   S_Max_Age         : in AWS.Messages.Delta_Seconds := 
     AWS.Messages.Unset;
   Public            : in Boolean := False;       
   Must_Revalidate   : in Boolean := True;       
   Proxy_Revalidate  : in Boolean := False);
\end{lstlisting}
%
\end{minipage}

This procedure creates the compressed cache directory, if it doesn't
already exist, and if it exists, it deletes everything in it. So basically
you're left with an empty directory after a call to this procedure. 

If \emph{Log\_To\_Info\_Trace} is \emph{False} then no information
about the deletion and creation of the compressed cache directory
is logged to the rotating log Info trace.

The remaining parameters defines the content of the \emph{Cache-Control}
header sent to the user agent when a request for static content is
made. The default settings are fairly sane, and will result in a cache
header looking like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
Cache-Control: max-age=86400, must-revalidate
\end{lstlisting}
%
\end{minipage}

Read the \href{http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\#sec14.9}{HTTP/1.1 Cache-Control header definition}
for more information on what the various settings do.

You must call \emph{Static\_Content\_Cache\_Setup} prior to starting
the HTTP(S) server, if you plan on using the \emph{Yolk.Static\_Content}
package. Calling it repeatedly will simply wipe out the compressed
cache directory and reset the \emph{Control\_Cache} header according
to the given parameters. This is a threadsafe operation.


\subsection{Yolk.Static\_Content.Compressable}

If your application contains a bunch of compressable files of significant
size, you can save a lot of bandwidth by using the \emph{Compressable}
function to serve them:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function Compressable      
  (Request : in AWS.Status.Data)       
   return AWS.Response.Data;
\end{lstlisting}
%
\end{minipage}

A natural place to call this function would be where you define your
content handlers, as seen in this, slightly altered, excerpt from
the \emph{Yolk.Handlers} package:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare

   package SC renames Yolk.Static_Content;

   Resource_Handlers : AWS.Services.Dispatchers.URI.Handler;

begin

   AWS.Services.Dispatchers.URI.Register_Regexp         
     (Dispatcher  => Resource_Handlers,          
      URI         => "\.css$",          
      Action      => Create (Callback => SC.Compressable'Access));

   AWS.Services.Dispatchers.URI.Register_Regexp         
     (Dispatcher  => Resource_Handlers,          
      URI         => "\.html$",          
      Action      => Create (Callback => SC.Compressable'Access));

end;
\end{lstlisting}
%
\end{minipage}

Here you can see that we've defined some content handlers for CSS
and HTML files based on a few simple regular expressions, and whenever
a resource is requested that matches one of these, the corresponding
\emph{Action} callback is called, which in this example is the \emph{Compressable}
function. The following steps are then taken:
\begin{enumerate}
\item Does the requested resource exist and is it an ordinary file?

\begin{enumerate}
\item If no, then return a 404 message
\item if yes, then proceed to 2
\end{enumerate}
\item Does the client support compressed content?

\begin{enumerate}
\item If no, then return the requested resource un-compressed
\item if yes, then proceed to 3
\end{enumerate}
\item Is there a compressed version of the resource available on disk?

\begin{enumerate}
\item if no, then make one, save it to disk, and return it
\item If yes, then proceed to 4
\end{enumerate}
\item Is the age of the compressed file <= Compressed\_Max\_Age?

\begin{enumerate}
\item If no, then delete the current file, build a new one and return it
\item If yes, then return it
\end{enumerate}
\end{enumerate}
And that's really all there is to it. Note that \emph{Compressable}
always looks for requested content in the \emph{WWW\_Root} directory,
so if the user requests the file \emph{/css/index.css}, then the path
is going to be:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
WWW_Root & "/css/index.ss";
\end{lstlisting}
%
\end{minipage}

Using the default configuration value for \emph{WWW\_Root}, we'll
end up with the path:
\begin{lyxcode}
static\_content/css/index.css
\end{lyxcode}
The compressed version of \emph{index.css} is saved as:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
Compressed_Cache_Directory & "/css/index.css" & ".gz";
\end{lstlisting}
%
\end{minipage}

Using the default configuration value for \emph{Compressed\_Cache\_Directory},
we'll end up with the path:
\begin{lyxcode}
static\_content/compressed\_cache/css/index.css.gz
\end{lyxcode}
In these two cases the paths are relative to the executable, but you
can of course also define \emph{WWW\_Root} and \emph{Compressed\_Cache\_Directory}
as absolute paths in the configuration file.


\subsection{Yolk.Static\_Content.Non\_Compressable}

A lot of static content really doesn't benefit from any further compression.
This is the case for PNG files, JPEG files and a whole lot of other
kinds of files. Static content that has already been compressed, should
be handled by the \emph{Non\_Compressable} function:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function Non_Compressable      
  (Request : in AWS.Status.Data)       
   return AWS.Response.Data;
\end{lstlisting}
%
\end{minipage}

A call to \emph{Non\_Compressable} is much simpler compared to a call
to it's sibling function \emph{Compressable}:
\begin{enumerate}
\item Does the requested resource exist and is it an ordinary file?

\begin{enumerate}
\item If no, then return a 404 message
\item if yes, then return the file
\end{enumerate}
\end{enumerate}
And that's it. Either the resource is there, or it isn't. If the requested
resource is \emph{/css/index.css}, then the \emph{Non\_Compressable}
function searches for the resource in:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
WWW_Root & "/css/index.ss";
\end{lstlisting}
%
\end{minipage}

Using the default configuration value for \emph{WWW\_Root}, we'll
end up with the path:
\begin{lyxcode}
static\_content/css/index.css
\end{lyxcode}
Just as with \emph{Compressable} a natural place to use \emph{Non\_Compressable}
is where you define you content handlers, but it can obviously be
used wherever your application handles requests for static content.


\section{Yolk.Syndication}

The Atom Syndication format (\href{http://tools.ietf.org/html/rfc4287}{RFC4287})
is an XML-based document format that describes lists of related information
known as \textquotedbl{}feeds\textquotedbl{}. Atom documents are used
by many web applications as a means of publishing information to users.
It's not a complicated format, but it does require a bit of work to
construct a proper Atom feed by hand, and since I try my best to avoid
work, I made the \emph{Yolk.Syndication} package. This package makes
it {}``easy'' to put together an Atom feed document, and have it
delivered as a string or an XML/Ada DOM object.

\emph{Yolk.Syndication} helps you construct the Atom XML - it does
not check that the resulting XML is valid Atom XML, ie. that the Atom
rules have been followed, so if the Atom specification says that
\begin{quote}
atom:feed elements MUST contain exactly one atom:id element.
\end{quote}
then it is your job to make sure that your Atom feed has exactly one
ID. So before venturing into the realm of Atom, it's probably a good
idea to read \href{http://tools.ietf.org/html/rfc4287}{RFC4287} for
a good understanding of the requirements for this document format.
A basic example of how to build an Atom feed can be found in the Yolk
demo application.

There are two packages in the \emph{Yolk.Syndication} hierarchy:
\begin{itemize}
\item \emph{Yolk.Syndication} - Here the necessary types and exceptions
are defined.
\item \emph{Yolk.Syndication.Writer} - Here the functions and procedures
for actually creating an Atom feed is are defined.
\end{itemize}
When time permits, I'll add a \emph{Yolk.Syndication.Reader} package
for extraction of data from an Atom feed.


\subsection{Exceptions}

There's one exception in this package:
\begin{itemize}
\item \emph{Not\_Valid\_XML}. Is raised when some Xhtml content is not valid
XML. This exception can be raised by all procedures that can take
Xhtml as content.
\end{itemize}

\subsection{The Yolk.Syndication types}

There are 5 important types in this package:
\begin{itemize}
\item \emph{Text\_Kinds}
\item \emph{Relation\_Kinds}
\item \emph{Atom\_Entry}
\item \emph{Atom\_Entry\_Source}
\item \emph{Atom\_Feed}
\end{itemize}
A few of the procedures in \emph{Yolk.Syndication.Writer} has parameters
of the \emph{Text\_Kinds} type. This identifies the kind of data that
is being added, with possible values being 
\begin{itemize}
\item \emph{Text} 
\item \emph{Html}
\item \emph{Xhtml}
\end{itemize}
Hopefully it's obvious what each of these refers to. Procedures that
have parameters of the \emph{Text\_Kinds} type always add data to
the feed that can be interpreted as one of these three kinds of text.

The \emph{Relation\_Kinds} type is used in correlation with links
that are added to the feed. It identifies how the link relates to
the current feed/entry. There are 5 possible relations:
\begin{itemize}
\item \emph{Alternate}: Signifies that the link points to an alternate version
of the resource described by the containing element.
\item \emph{Related}: Signifies that the link points to a resource that
is related to, but not the same as, the resource described by the
containing element.
\item \emph{Self}: Signifies that the link points to a resource that is
equivalent to the resource described by the containing element. All
feeds should have one link with a \emph{Self} relation.
\item \emph{Enclosure}: Signifies that the link points to a resource that
is related to, but not the same as, the resource described by the
containing element. It also signifies that the resource potentially
is large in size and might require special handling. If \emph{Enclosure}
is used, then usually the \emph{Length} parameter is set to hint at
the size of the resource.
\item \emph{Via}: Signifies that the resource provided by the containing
element originates in the URI given by the \emph{Href} parameter of
the link element.
\end{itemize}
Finally we have the most important types:
\begin{itemize}
\item \emph{Atom\_Entry}: An entry in a feed.
\item \emph{Atom\_Entry\_Source}: The origin of an entry.
\item \emph{Atom\_Feed}: The Atom feed.
\end{itemize}
These are core to the functionality of \emph{Yolk.Syndication}, and
every single procedure and function in the \emph{Yolk.Syndication.Writer}
package use one or the other. These three types are \emph{private},
so the only way to declare an object of either one, is by calling
the \emph{New\_Atom\_Feed}, \emph{New\_Atom\_Entry} or \emph{New\_Atom\_Entry\_Source}
functions respectively.

Note that only \emph{Atom\_Feed} is thread safe. The two entry related
types are not.


\subsection{Yolk.Syndication.New\_Atom\_Feed}

This function initialize an \emph{Atom\_Feed} type, and its specification
looks like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function New_Atom_Feed      
  (Base_URI    : in String := None;       
   Language    : in String := None;       
   Max_Age     : in Duration := 5_616_000.0;       
   Max_Entries : in Positive := 100;       
   Min_Entries : in Positive := 10)       
   return Atom_Feed;
\end{lstlisting}
%
\end{minipage}

The \emph{Base\_URI} parameter establish a base for resolving relative
references in the feed. The \emph{Language} parameter indicates the
natural language used in the feed. \emph{Max\_Age} is a duration that
determine when an entry in the feed is old enough to be deleted. \emph{Max\_Entries}
is the amount of entries kept in the feed. If there are more than
this amount of entries in the feed, then the oldest are deleted until
the feed contains \emph{Max\_Entries} entries again. \emph{Min\_Entries}
is the minimum amount of entries that must be present in the feed,
before we bother deleting entries whose age is > \emph{Max\_Age}.
If there are less than \emph{Min\_Entries} entries in the feed, then
we keep even a 100 year old entry.

What these parameters hints at, is that some automatic maintenance
is done when using \emph{Yolk.Syndication}, and this is indeed true.
Usually you do not want a feed to grow forever, and instead of having
to manually clear away old stuff, \emph{Yolk.Syndication} handles
all this for you, according to the values given when you instantiate
an \emph{Atom\_Feed} object using \emph{New\_Atom\_Feed}.


\subsection{Yolk.Syndication.New\_Atom\_Entry}

This function initialize and \emph{Atom\_Entry} type, and its specification
looks like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function New_Atom_Entry      
  (Base_URI : in String := None;       
   Language : in String := None)       
   return Atom_Entry;
\end{lstlisting}
%
\end{minipage}

As you can see, it's a lot simpler than the \emph{New\_Atom\_Feed}
function. This is of course because all the automatic maintenance
related parameters have already been set by they \emph{New\_Atom\_Feed}
function. All that is left is to define the \emph{Base\_URI} and the
natural \emph{Language} used by the entry.


\subsection{Yolk.Syndication.New\_Atom\_Entry\_Source}

This function initialize and \emph{Atom\_Entry\_Source} type, and
its specification looks like this:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function New_Atom_Entry_Source      
  (Base_URI : in String := None;       
   Language : in String := None)       
   return Atom_Entry_Source;
\end{lstlisting}
%
\end{minipage}

As you can see, this is very similar to the \emph{New\_Atom\_Entry}
function, since its job is to return an \emph{Atom\_Entry\_Source}
object, which is basically just an object that describes the origins
of a feed entry.


\subsection{Yolk.Syndication.Writer}

In this package we find all the tools necessary to build the Atom
XML. There are far too many subprograms in \emph{Yolk.Syndication.Writer}
to list here, so instead I'll refer you to the source code. All the
subprograms in this package work on one of the \emph{Atom\_Feed},
\emph{Atom\_Entry} or \emph{Atom\_Entry\_Source} types, for example
if you want to set a title on your feed, you'll use the \emph{Set\_Title}
procedure:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Set_Title      
  (Feed       : in out Atom_Feed;       
   Title      : in     String;       
   Base_URI   : in     String := None;       
   Language   : in     String := None;       
   Title_Kind : in     Text_Kinds := Text);
\end{lstlisting}
%
\end{minipage}

Or if the title is for an entry, then:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Set_Title      
  (Entr       : in out Atom_Entry;       
   Title      : in     String;       
   Base_URI   : in     String := None;       
   Language   : in     String := None;       
   Title_Kind : in     Text_Kinds := Text);
\end{lstlisting}
%
\end{minipage}

Or we could add an author to the feed/entry/entry source:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Add_Author      
  (Feed     : in out Atom_Feed;       
   Name     : in     String;       
   Base_URI : in     String := None;       
   Email    : in     String := None;       
   Language : in     String := None;       
   URI      : in     String := None);

procedure Add_Author      
  (Entr     : in out Atom_Entry;       
   Name     : in     String;       
   Base_URI : in     String := None;       
   Email    : in     String := None;       
   Language : in     String := None;       
   URI      : in     String := None);

procedure Add_Author      
  (Entry_Source : in out Atom_Entry_Source;       
   Name         : in     String;       
   Base_URI     : in     String := None;       
   Email        : in     String := None;       
   Language     : in     String := None;       
   URI          : in     String := None);
\end{lstlisting}
%
\end{minipage}

There's actually a hint about the kind of XML element that is being
produced by these procedures. If the name of the procedure starts
with \emph{Set\_} then it hints at an XML element of which there's
only ever one. So \emph{Set\_Title} create a \emph{<title>Foo</title>}
element, and if called again, overwrites the previous value, whereas
if the name of procedure starts with \emph{Add\_} then the Atom specification
allows for multiples of these, as can be seen with the \emph{Add\_Author}
procedure. Calling this one creates an \emph{<author>} element, and
calling it again simply adds one more author to the feed/entry/entry
source.

Most of the subprograms in this package deals directly with building
the Atom XML, but there are a few exceptions. We'll go over these
now.


\subsection{Counting the amount of entries in a feed}

If you need to know how many entries that are currently in a feed,
the you can use the \emph{Yolk.Syndication.Writer.Amount\_Of\_Entries}
function:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function Amount_Of_Entries      
  (Feed : in Atom_Feed)       
   return Natural;
\end{lstlisting}
%
\end{minipage}


\subsection{Clearing and deleting entries}

There are two procedures available for clearing and deleting entries,
one for clearing all entries away, and one for deleting entries based
on their Id. Lets start with the one that clears out everything:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Clear_Entry_List      
  (Feed : in out Atom_Feed);
\end{lstlisting}
%
\end{minipage}

Calling \emph{Clear\_Entry\_List} deletes every single entry that
has been added to the \emph{Feed} object so far. A less destructive
procedure is \emph{Delete\_Entry}:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Delete_Entry      
  (Feed : in out Atom_Feed;       
   Id   : in     String);
\end{lstlisting}
%
\end{minipage}

Using this one, you can delete all entries whose Id is \emph{Id}.
Note that the match must be exact, so case matters. FOO is not the
same as foo.


\subsection{Getting the Atom feed}

When you've added titles, authors, categories, entries and content
to your feed, the next step is turning it into XML. This can be done
in one of two ways:
\begin{enumerate}
\item As string XML.
\item As an XML/Ada DOM XML object.
\end{enumerate}
The string XML is obviously for the final audience, whereas the DOM
XML is useful if you need to do some further work on the feed before
releasing it on the world. Here they are:

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function Get_XML_DOM      
  (Feed : in Atom_Feed)       
   return DOM.Core.Document;

function Get_XML_String      
  (Feed         : in Atom_Feed;       
   Pretty_Print : in Boolean := False)       
   return String;
\end{lstlisting}
%
\end{minipage}

Note that if \emph{Pretty\_Print} is \emph{True} then whitespace is
going get mangled according to these rules:
\begin{quote}
If Pretty\_Print is true, then the XML nodes will be indented so that
children nodes are to the right of their parents. It is set to False
by default because its use changes the document (addition or removal
of whitespaces among other things), which in general has no effect
for automatic tools reading the document. All whitespaces are modified
outside of elements containing nothing but text nodes. For text nodes,
leading and trailing whitespaces are also deleted.
\end{quote}
\emph{Get\_XML\_String} relies on the \emph{Write} function from XML/Ada
to generate its output, and the above quote is taken straight from
the XML/Ada source comments. It's also worth noting that \emph{Get\_XML\_String}
and \emph{Get\_XML\_DOM} both are pretty resource-hungry, so it's
probably best to cache the results for later use, instead of calling
them on each and every hit.


\section{Yolk.Utilities}

This package contains various support functionality or simple renames
of other subprograms, such as renaming the unyielding \emph{To\_Unbounded\_String}
function to the more manageable \emph{TUS}. Check the \emph{yolk-utilities.ads}
source file for more information.


\section{Yolk.Whoops}

This package contains one single procedure: \emph{Unexpected\_Exception\_Handler}.
I suspect the name gives away exactly what this procedure does. It
looks like this:'

\begin{minipage}[t]{1\columnwidth}%
\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Unexpected_Exception_Handler      
  (E      : Ada.Exceptions.Exception_Occurrence;       
   Log    : in out AWS.Log.Object;       
   Error  : AWS.Exceptions.Data;       
   Answer : in out AWS.Response.Data);
\end{lstlisting}
%
\end{minipage}

You can use this procedure to catch any and all exceptions you've
failed to catch in your application, ie. the ones AWS pickup and fail
to do anything sensible with. When \emph{Unexpected\_Reception\_Handler}
catch an exception, two things happen:
\begin{enumerate}
\item The exception is logged to the rotating log system in the \emph{Error}
trace.
\item A HTTP status code 500 is returned to the user.
\end{enumerate}
The template used to create the HTTP code 500 error message is\emph{
demo/exe/templates/system/500.tmpl}. You can of course change this
to match the look and feel of your application. The path to the \emph{500.tmpl}
file is set by the configuration setting \emph{System\_Templates\_Path}. 

You can see an example on how to use this procedure in the file \emph{demo/src/yolk\_demo.adb}.
\end{document}
