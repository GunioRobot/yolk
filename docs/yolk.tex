%% LyX 1.6.10 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2cm,bmargin=2cm,lmargin=2cm,rmargin=2cm}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{babel}

\usepackage[unicode=true]
 {hyperref}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxcode}
{\par\begin{list}{}{
\setlength{\rightmargin}{\leftmargin}
\setlength{\listparindent}{0pt}% needed for AMS classes
\raggedright
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\normalfont\ttfamily}%
 \item[]}
{\end{list}}

\makeatother

\begin{document}

\title{Yolk Manual}


\date{Revised July 22nd. 2011}

\maketitle
\newpage{}

\tableofcontents{}

\newpage{}


\part{General Information}


\section{What is Yolk?}

Yolk is a collection of packages that aim to help build solid web-applications
using Ada. Yolk itself doesn't do a whole lot that can't be accomplished
simply by using \href{http://libre.adacore.com/libre/tools/aws/}{AWS}
and the \href{http://libre.adacore.com/libre/tools/gnat-component-collection/}{GNAT Component Collection (GNATcoll)},
but it does make the job of building complete web-applications a bit
simpler. Things like changing user for the running application, accessing
multiple databases, automatically cleaning up log files, adding basic
static content handlers and building ATOM syndication XML are all
handled by Yolk.

A Yolk application is in reality an AWS application, with some sugar
added, so you're not really building a Yolk web-application, as much
as you're building an AWS web-application. What I'm getting at, is
that you need to understand how to use AWS, in order for Yolk to make
any kind of sense. What you get when using Yolk is the little things
that AWS does not readily provide.


\subsection{The Yolk demo application}

Reading this manual will of course (I hope!) help you understand how
to use Yolk, but please consider taking a closer look at the Yolk
demo application to get a feel for how Yolk is actually used. The
demo is heavily commented, so it should be fairly easy to understand
what's going on. The demo application is also very suitable as a foundation
for other AWS/Yolk applications.

It is much easier to show how to use Yolk, than it is to write down
all possible usage scenarios. With the combination of this manual,
the Yolk source files and the demo application, you should be able
to make full use of the Yolk packages in your own applications.


\subsection{The source code}

The Yolk source code is the best documentation there is. This document
is never going to be as comprehensive as the actual source, so I'll
strongly suggest having the source code available as you read this
document. What you will find in this document are short descriptions
of what a package is meant to do and small usage examples, not a complete
rundown of every type and procedure in a package.


\subsection{Building and installing Yolk}

See the README and INSTALL files. These are found in the Yolk root
directory.


\subsection{The files Yolk depend upon}

When you read this document and the Yolk source code, you'll notice
that quite a few packages depend on various files being available
at specified locations. This is for example the case with the \emph{Yolk.Configuration}
package, that must have a \emph{config.ini} file available in the
\emph{configuration/} directory, or the \emph{Yolk.Whoops} package
that expects its template file to be found at the path \emph{templates/system/500.tmpl}

All such {}``dependencies'' will of course be noted accordingly
as we go along, but instead of forgetting one or more in your own
application, I'd much rather encourage using the demo application
as a foundation for your own applications, since all these fixed paths
and files has been properly added to the demo.

I also recommend compiling and running the demo, to make sure your
Yolk install is working as intended. Just read the \emph{demo/README}
and \emph{demo/INSTALL} files for instructions on how to get it up
and running.


\subsection{The Yolk packages naming}

The Yolk packages are pretty diverse, ranging from process control
to sending email. I've tried naming them as sensibly as possible,
in the hope that the package names alone give away their function.
If I've failed, well, you're just going to have to refer to this document
or take a look at the source for yourself.

\newpage{}


\part{The Yolk Packages}


\section{Yolk}

The Yolk main package currently only contain one thing: The Yolk \emph{Version}
string. This is used in a few places, for example in the \emph{directory.tmpl}
template file, but obviously it's not something that's of vital importance
to most applications.


\section{Yolk.Cache.Discrete\_Keys}

If a piece of data doesn't change very often and it is expensive to
build, then caching it might be worthwhile. Instead of going to file/database
on every hit, you simply go to the cache and grab the latest version
from there. This is \textbf{\emph{very}} fast, at the cost of some
memory.

If you know exactly what you want to cache, the \emph{Yolk.Cache.Discrete\_Keys}
package might be just what you need.


\subsection{The generic formal parameters}

These are:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
generic
   type Key_Type is (<>);
   type Element_Type is private;
   Max_Element_Age : Duration := 3600.0;
package Yolk.Cache.Discrete_Keys is
...
\end{lstlisting}
%
\end{minipage}

The \emph{Max\_Element\_Age} defaults to one hour. You should obviously
set this to whatever suits your needs. This timer is used for all
content in the cache. You cannot set this individually for each element.


\subsection{Instantiation}

If for example we have two different sets of data (Foo and Bar) that
are expensive to build, we can instantiate a \emph{Discrete\_Keys}
package to handle this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
type Cache_Keys is (Foo, Bar);
package My_Cache is new Yolk.Cache.Discrete_Keys
  (Key_Type     => Cache_Keys,
   Element_Type => Unbounded_String);
\end{lstlisting}
%
\end{minipage}

And that is all. We now have a \emph{My\_Cache} object that can hold
two objects: \emph{Foo} and \emph{Bar}. These are of the type \emph{Unbounded\_String}
and they have a \emph{Max\_Element\_Age} of 3600.0 seconds.


\subsection{Writing to the cache}

Before we can read something from the cache, we must first write something
to it:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   Foo_Value : Unbounded_String := To_Unbounded_String ("Foo");
begin
   My_Cache.Write (Key   => Foo,
                   Value => Foo_Value);
end;
\end{lstlisting}
%
\end{minipage}

That is all it takes: {}``Foo'' is now safely tucked away in the
\emph{My\_Cache} object, and will be so for 3600.0 seconds. Calling
\emph{Write} with the \emph{Foo }key will always overwrite earlier
written \emph{Foo} elements, no matter their age.


\subsection{Reading from the cache}

A cache obviously only makes sense if you intend to read from it.
In our case we want to get our hands on the previously written {}``Foo''
value:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   Valid : Boolean := False;
   Value : Unbounded_String;
begin
   My_Cache.Read (Key      => Foo,
                  Is_Valid => Valid,
                  Value    => Value);
   if Valid then
      --  do something interesting with the data
   else
      --  the Foo data is invalid.
   end if;
end;
\end{lstlisting}
%
\end{minipage}

In order for an element to be valid (the\emph{ Is\_Valid} parameter
is true), it must:
\begin{enumerate}
\item have been added to the cache in the first place
\item be younger than \emph{Max\_Element\_Age}
\end{enumerate}
If \emph{Is\_Valid} is \emph{False}, then \emph{Value} contains undefined
garbage.


\subsection{Checking if a key is valid}

If you need to check whether a specific key exists in the cache and
is valid, then you need to use the \emph{Is\_Valid} function.

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if My_Cache.Is_Valid (Foo) then
   --  Foo is good!
else
   --  Foo is bad!
end if;
\end{lstlisting}
%
\end{minipage}

This follows the same rules as the \emph{Is\_Valid} parameter for
the \emph{Read} procedure.


\subsection{Clearing keys and the entire cache}

For clearing of keys and the entire cache we have, naturally, two
\emph{Clear} procedures:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
-- First we clear the Foo key
My_Cache.Clear (Key => Foo);

--  And then we clear the entire cache
My_Cache.Clear;
\end{lstlisting}
%
\end{minipage}

And that's all it takes.


\section{Yolk.Cache.String\_Keys}

This package is almost similar to the \emph{Yolk.Cache.Discrete\_Keys}
package. The biggest difference is that where the \emph{Discrete\_Keys}
cache package requires that you define a type for the keys, this packages
takes a regular \emph{String} as key.

The implications of this difference between the two cache packages
are subtle. Both have the same \emph{Read}, \emph{Write}, \emph{Is\_Valid}
and \emph{Clear} procedures and functions, so in that sense the two
packages are the same. The biggest difference lies in the available
generic formal parameters and the addition of the \emph{Cleanup} procedure
and the \emph{Length} function.


\subsection{The generic formal parameters}

These are:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
generic
   type Element_Type is private;
   Cleanup_Size      : Positive := 200;
   Cleanup_On_Write  : Boolean  := True;
   Max_Element_Age   : Duration := 3600.0;
   Reserved_Capacity : Positive := 100;
package Yolk.Cache.Discrete_Keys is
...
\end{lstlisting}
%
\end{minipage}

When the amount of elements in the cache >= \emph{Cleanup\_Size},
then the \emph{Cleanup} procedure is called by \emph{Write}, if \emph{Cleanup\_On\_Write}
is set to Boolean \emph{True}. \emph{Cleanup\_Size} is a sort of failsafe
for this cache package. Since we can't know for sure what is being
added (we don't know the keys beforehand), we need to make sure it
doesn't gobble up all available resources. Set this number high enough
that it'll never tricker under normal circumstances, but low enough
that it'll prevent resource exhaustion in case of errors.

The \emph{Max\_Element\_Age} defaults to one hour. You should obviously
set this to whatever suits your needs. This timer is used for all
content in the cache. You cannot set this individually for each element.

\emph{Reserved\_Capacity} should be set as close as possible to the
expected final size of the cache. If your best guestimate is 200 elements
in the cache, then set this to 200. Note that this setting has no
bearing has no bearing on the actual size of the cache. The cache
will happily grow beyond the \emph{Reserved\_Capacity} value.


\subsection{Instantiation}

Instantiating \emph{String\_Keys} is done like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
package My_Cache is new Yolk.Cache.String_Keys
  (Element_Type      => Unbounded_String,
   Reserved_Capacity => 200);
\end{lstlisting}
%
\end{minipage}

And that is all. We now have a \emph{My\_Cache} object that can hold
200 objects of the type \emph{Unbounded\_String}, all of which have
a \emph{Max\_Element\_Age} of 3600.0 seconds. 


\subsection{Writing to the cache}

Before we can read something from the cache, we must first write something
to it:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   Value : Unbounded_String := To_Unbounded_String ("42");
begin
   My_Cache.Write (Key   => "Foo",
                   Value => Value);
end;
\end{lstlisting}
%
\end{minipage}

That is all it takes: {}``42'' is now safely tucked away in the
\emph{My\_Cache} object under the key {}``Foo'', and will be so
for 3600.0 seconds. Calling \emph{Write} with the {}``Foo''\emph{
}String will always overwrite earlier written {}``Foo'' elements,
no matter their age.


\subsection{Reading from the cache}

A cache obviously only makes sense if you intend to read from it.
In our case we want to get our hands on the previously written {}``Foo''
value:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   Valid : Boolean := False;
   Value : Unbounded_String;
begin
   My_Cache.Read (Key      => "Foo",
                  Is_Valid => Valid,
                  Value    => Value);
   if Valid then
      --  do something interesting with the data
   else
      --  the Foo data is invalid.
   end if;
end;
\end{lstlisting}
%
\end{minipage}

In order for an element to be valid (the\emph{ Is\_Valid} parameter
is true), it must:
\begin{enumerate}
\item have been added to the cache in the first place
\item be younger than \emph{Max\_Element\_Age}
\end{enumerate}
If \emph{Is\_Valid} is \emph{False}, then \emph{Value} contains undefined
garbage.


\subsection{Checking if a key is valid}

If you need to check whether a specific key exists in the cache and
is valid, then you need to use the \emph{Is\_Valid} function.

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if My_Cache.Is_Valid ("Foo") then
   --  Foo is good!
else
   --  Foo is bad!
end if;
\end{lstlisting}
%
\end{minipage}

This follows the same rules as the \emph{Is\_Valid} parameter for
the \emph{Read} procedure.


\subsection{Clearing keys and the entire cache}

For clearing of keys and the entire cache we have, naturally, two
\emph{Clear} procedures:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
-- First we clear the Foo key
My_Cache.Clear (Key => "Foo");

--  And then we clear the entire cache
My_Cache.Clear;
\end{lstlisting}
%
\end{minipage}

And that's all it takes.


\subsection{How much is in there?}

With the \emph{Discrete\_Keys} cache we obviously always now the exact
amount of keys available, since we've defined the keys ourselves.
This is not the case with the \emph{String\_Keys} cache, where any
String can be a key. If we need to know how many elements that are
currently in the cache, we call the \emph{Length} function:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if My_Cache.Length > 1000 then
   --  Woa! Lots of stuff in the cache..
end if;
\end{lstlisting}
%
\end{minipage}

Note that \emph{Length} count both valid and invalid elements.


\subsection{Cleanup - Keeping cache size in check}

if \emph{Cleanup\_On\_Write} is \emph{True}, then \emph{Cleanup} is
called by \emph{Write }whenever the size of the cache reach \emph{Cleanup\_Size}.
It is of course also possible to call it manually:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if My_Cache.Length > 1000 then
   My_Cache.Cleanup;
end if;
\end{lstlisting}
%
\end{minipage}

If you've set \emph{Cleanup\_On\_Write} to Boolean \emph{False} and
the String keys are coming from outside sources, then you really should
make sure you call \emph{Cleanup} on a regular basis. 


\section{Yolk.Config\_File\_Parser}

This package enable you to access KEY/VALUE pairs in configuration
files that are written in the style:
\begin{lyxcode}
\#~This~is~a~comment

-{}-~This~is~also~a~comment

KEY~VALUE
\end{lyxcode}
Keys are case-insensitive, so \emph{FOO}, \emph{foo} and \emph{fOo}
are all the same.\emph{ }Blank lines and comments are ignored and
so is pre/postfixed whitespace. It is not necessary to quote values
that contain whitespace, to this:
\begin{lyxcode}
KEY~some~value~with~whitespace
\end{lyxcode}
is perfectly valid, and will return {}``\emph{some value with whitespace}''
when calling \emph{Get (KEY)}. If VALUE is Boolean True or False (case-insensitive),
then the KEY can be returned as a String or a Boolean, depending on
the target type. If the target type does not match the VALUE and no
sensible conversion can be made, then a \emph{Conversion\_Error} exception
is raised. No dummy values are returned at any time.

To clear a default value, simply add the key to the configuration
file, with no value set.


\subsection{The generic formal parameters}

These are:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
generic
   use Ada.Strings.Unbounded;
   type Key_Type is (<>);
   type Defaults_Array_Type is array (Key_Type) of Unbounded_String;
   Defaults    : in Defaults_Array_Type;    
   Config_File : in String := "configuration/config.ini";
package Yolk.Config_File_Parser is
...
\end{lstlisting}
%
\end{minipage}

Note that the \emph{Config\_File} parameter has a default value. This
path is actually where Yolk expects to find the configuration file
used by the Yolk.Configuration package.


\subsection{Exceptions}

There are 3 different exceptions that can be raised by the \emph{Yolk.Config\_File\_Parser}
package. These are:
\begin{itemize}
\item \emph{Unknown\_Key}. This is raised if an unknown key has been found
in the configuration file given when instantiating the package or
when \emph{Load\_File} is called.
\item \emph{Cannot\_Open\_Config\_File}. This is raised when a configuration
file cannot be read.
\item \emph{Conversion\_Error}. This is raised when a value cannot be converted
to the target type, ie. the value {}``42'' to a Boolean.
\end{itemize}

\subsection{Instantiation}

\emph{Yolk.Config\_File\_Parser} is a generic package, so in order
to use it, you have to instantiate it, like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
package My_Configuration is

   type Keys is (Foo, Bar);
   type Defaults_Array is array (Keys) of
     Ada.Strings.Unbounded.Unbounded_String;

   Default_Values : constant Defaults_Array :=
                      (Foo => TUS ("some foo"),
                       Bar => TUS ("some bar"));
   --  TUS is a rename of the To_Unbounded_String function. It
   --  is found in the Yolk.Utilities package.

   package Config is new Yolk.Config_File_Parser
     (Key_Type => Keys,
      Defaults_Array_Type => Defaults_Array,
      Defaults => Default_Value,
      Config_File => "config.ini");

end My_Configuration;
\end{lstlisting}
%
\end{minipage}

Here we instantiate the \emph{Config} package with \emph{config.ini}
as the configuration file. This means that KEY/VALUE pairs found in
this file will overwrite the default values set in the \emph{Default\_Values}
array. Setting a default value to \emph{Null\_Unbounded\_String} means
the value is empty.


\subsection{Re-loading configuration files}

With the \emph{Load\_File} procedure you can re-load a new configuration
file into your \emph{Config} package:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
My_Configuration.Config.Load_File ("new_config.ini");
\end{lstlisting}
%
\end{minipage}

And that is all. Now the KEY/VALUE pairs of \emph{new\_config.ini}
will overwrite the ones originally found in the \emph{config.ini}
file the package was instantiated with. You can do this as many times
as you like. Note that you cannot change what KEY's are valid, so
if the \emph{new\_config.ini} file contains unknown keys, \emph{Load\_File}
will raise the \emph{Unknown\_Key} exception.


\subsection{Getting values}

With instantiation and loading of configuration files out of the way,
it is now time to get to the configuration values. To get the value
of the \emph{Foo} key, you do:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
My_Configuration.Config.Get (Foo);
\end{lstlisting}
%
\end{minipage}

There are Get functions for the following types:
\begin{itemize}
\item Boolean
\item Duration
\item Float
\item Integer
\item String
\item Unbounded\_String
\end{itemize}
Empty keys simply return an empty String or a \emph{Null\_Unbounded\_String},
depending on the target type. If a key is empty and the target type
is not a String or an Unbounded\_String, then the \emph{Conversion\_Error}
exception is raised.


\subsection{Checking if a KEY has a VALUE}

You can check if a key has a value with the \emph{Has\_Value} function:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
if Has_Value (Foo) then
   Put_Line ("Foo has a value");
end if;
\end{lstlisting}
%
\end{minipage}

Basically all this function does is return Boolean True if the value
of the given key is not a \emph{Null\_Unbounded\_String}.


\section{Yolk.Configuration}

This package is a bit of an oddball, as all it does is instantiate
the \emph{Yolk.Config\_File\_Parser} generic with the default AWS
and Yolk configuration values. This is used by Yolk internally, but
also possibly by the AWS component of your application. The instantiation
looks like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
package Config is new Config_File_Parser
  (Key_Type => Keys,
   Defaults_Array_Type => Defaults_Array,
   Defaults => Default_Values,
   Config_File => "configuration/config.ini");
\end{lstlisting}
%
\end{minipage}

As you can see, it is required that there's a configuration file found
in \emph{configuration/config.ini}. This path is of course relative
to the application. There's a fully commented \emph{config.ini} file
available in \emph{demo/exe/configuration/}. This setup is required
if you're using Yolk, and the only way to avoid having \emph{config.ini}
in the mentioned directory is if you manually change the path in the
source file before compiling Yolk.

I recommend taking a look at the Yolk demo application to see how
the \emph{Yolk.Configuration} package is used.


\subsection{Get the AWS specific configuration settings}

When you start an AWS server, you need to give it an \emph{AWS.Config.Object}
with all the necessary configuration settings. This is already handled
for you in \emph{Yolk.Configuration}, all you have to do is call the
\emph{Get\_AWS\_Configuration} function, like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
AWS_Config : constant AWS.Config.Object := 
  Yolk.Configuration.Get_AWS_Configuration;
AWS.Server.Start (Web_Server => Web_Server,
                  Dispatcher => Resource_Handlers,
                  Config     => AWS_Config);
\end{lstlisting}
%
\end{minipage}

You're not forced to use this, if you don't want to. But even if you
don't, you'll still have to make a valid configuration file available
in the configuration directory defined in the \emph{Config} instantiation,
so you might as well use this as the configuration foundation for
the AWS HTTP server component of your application. Again, see the
demo application for examples on how this is done.


\section{Yolk.Connect\_To\_DB}

This is a small wrapper for the \emph{GNATCOLL.SQL} database connection
functionality. Once you've connected to the database, you use plain
\emph{GNATCOLL.SQL} tools to query/update your database. The ability
to stay connected to several databases in the same application was
what drove the development of the \emph{Yolk.Connect\_To\_DB} package,
as the \emph{GNATCOLL.SQL.Exec.Get\_Task\_Connection} function did
not support that out of the box.

At the time of writing, GNATcoll supports PostgreSQL and SQLite, but
Yolk only supports connecting to PostgreSQL. The reason for this is
simple: I don't use SQLite now and I don't plan on using it in the
future, and if I can't test something, I don't feel like adding it
to Yolk.


\subsection{The Connection\_Mapping\_Method type}

To define how AWS threads are mapped to the database connections,
you need to understand the \emph{Connection\_Mapping\_Method} type.
There are two different methods of connecting to a database:
\begin{enumerate}
\item AWS\_Tasks\_To\_DB
\item DB\_Conn\_Tasks\_To\_DB
\end{enumerate}
The first method is the simplest and it's also the method that requires
fewest resources. Using method 1. we simply map each AWS thread to
a database connection, meaning that if you have 5 AWS threads, you're
going to end up with 5 open connections to your database. Whenever
an AWS thread ask for a database connection, it always get the same
connection. If no connection has been made yet, one is started and
mapped to the AWS thread that started it.

This works flawlessly as long as you don't need to connect to more
than one database, but it fails miserably if you have more than one
database in play. For such cases we need option 2. 

When option 2. is used, one set of database connection tasks are started
for every database you connect to. So if you have an AWS server with
5 threads and you need to connect to two databases, you're going to
end up with 5 small tasks whose only purpose in life is to open and
maintain a connection to the database. These 5 \emph{DB\_Conn} tasks
are then mapped to the AWS threads using the \emph{Ada.Task\_Attributes}
package.

This also means that you can only instantiate once using \emph{AWS\_Tasks\_To\_DB}
whereas you can instantiate as many times as you like with \emph{DB\_Conn\_Tasks\_To\_DB}.
If you need to connect to several databases, make sure that the one
you use the most is setup with the \emph{AWS\_Tasks\_To\_DB} connection
mapping. This is the fastest and most resource efficient method, as
we don't have to spend time going through one of the \emph{DB\_Conn}
tasks that are necessary with the \emph{DB\_Conn\_Tasks\_To\_DB} method.


\subsection{Database credentials}

The \emph{Set\_Credentials} function is responsible for setting the
credentials necessary to connect to the database.

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
Yolk.Connect_To_DB.Set_Credentials
  (Host     => "localhost",
   Database => "some_database",
   User     => "username",
   Password => "secret");
\end{lstlisting}
%
\end{minipage}

This call return a \emph{Yolk.Connect\_To\_DB.Credentials} type which
is then used when instantiating the \emph{Yolk.Connect\_To\_DB.PostgreSQL}
generic.


\section{Yolk.Connect\_To\_DB.PostgreSQL}

When instantiated, this package provides a single function: \emph{Connection}.
This function return a \emph{GNATCOLL.SQL.Exec.Database\_Connection}
type, which is then used to interact with your database.


\subsection{The generic formal parameters}

When you're actually going to connect to your PostgreSQL database(s),
this is the package you want. It's a generic with two formal parameters:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
generic
   DB_Credentials : Credentials;
   Task_To_DB_Mapping_Method : Connection_Mapping_Method;    
package Yolk.Connect_To_DB.PostgreSQL is
   function Connection return GNATCOLL.SQL.Exec.Database_Connection;
end Yolk.Connect_To_DB.PostgreSQL;
\end{lstlisting}
%
\end{minipage}

Instantiation is pretty straightforward:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
package My_DB is new Connect_To_DB.PostgreSQL      
  (DB_Credentials            => Connect_To_DB.Set_Credentials         
     (Host     => My.Config.Get (My.DB_Host),          
      Database => My.Config.Get (My.DB_Name),          
      User     => My.Config.Get (My.DB_User),          
      Password => My.Config.Get (My.DB_Password)), 
   Task_To_DB_Mapping_Method => Connect_To_DB.AWS_Tasks_To_DB);
\end{lstlisting}
%
\end{minipage}

In this case we've used the \emph{AWS\_Tasks\_To\_DB} mapping method,
so each AWS thread will be mapped to a specific database connection.


\subsection{Connecting to the database}

With the \emph{My\_DB} package up and running, connecting to the database
is done like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
DB_Conn : constant Database_Connection := My_DB.Connection;
\end{lstlisting}
%
\end{minipage}

\noindent You can now use the \emph{DB\_Conn} connection just as if
you'd created the \emph{Database\_Connection} object using the method
described in the \href{https://www.adacore.com/wp-content/files/auto_update/gnatcoll-docs/gnatcoll.html\#Database-interface}{GNAT Component Collection (GNATcoll) manual}.
There's also a usage example in the Yolk demo. Take a look at the
\emph{View.DB\_Test} package.


\section{Yolk.Email}

Using \emph{Yolk.Email} and the child package \emph{Yolk.Email.Composer}
you can build and send more or less any kind of email:
\begin{itemize}
\item Plain text
\item Multipart/Alternative
\item Multipart/Mixed
\end{itemize}
The package supports adding multiple SMTP servers, meaning you can
add as many as you need, and the email will then be send via the first
one that accepts it.

The \emph{Yolk.Email} package define 4 exceptions and 3 types. The
facilities for actually constructing and sending the email are found
in \emph{Yolk.Email.Composer}.


\subsection{Exceptions}

These are:
\begin{itemize}
\item \emph{Attachment\_File\_Not\_Found}. Is raised if a file attachment
is not found at the given path.
\item \emph{No\_Address\_Set}. Is raised if the address component of a To,
Reply-To, From, Bcc/Cc header is missing.
\item \emph{No\_Sender\_Set\_With\_Multiple\_From}. Is raised when an email
contains multiple From headers but no Sender header, as per RFC-5322,
3.6.2. http://tools.ietf.org/html/rfc5322
\item \emph{No\_SMTP\_Host\_Set}. Is raised if the SMTP host list is empty,
ie. no SMTP host has been set for sending the email.
\end{itemize}

\subsection{The Yolk.Email types}

When using \emph{Yolk.Email.Composer} to build and send emails, three
types declared in \emph{Yolk.Email} are central:
\begin{enumerate}
\item \emph{Character\_Set}
\item \emph{Recipient\_Kind}
\item \emph{Structure}
\end{enumerate}
The \emph{Character\_Set} type define what character set is used when
data is added to an email \emph{Structure} object. For example looking
at the \emph{Yolk.Email.Composer.Add\_From} procedure, we see that
the \emph{Charset} parameter defaults to \emph{US\_ASCII}:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Add_From      
  (ES        : in out Structure;       
   Address   : in     String;       
   Name      : in     String := "";       
   Charset   : in     Character_Set := US_ASCII);
\end{lstlisting}
%
\end{minipage}

This does not mean that \emph{Yolk.Email.Composer.Add\_From} will
encode \emph{Name} as \emph{US\_ASCII}, instead it means that the
data given in \emph{Name} is already encoded as \emph{US\_ASCII}.
So if \emph{Name} had contained an ISO-8859-1 encoded String, then
the call would've looked like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   use Yolk.Email;

   Email : Structure;
begin
   Composer.Add_From      
     (ES        => Email,       
      Address   => "thomas@12boo.net",
      Name      => "Thomas Løcke",
      Charset   => ISO_8859_1);
end;
\end{lstlisting}
%
\end{minipage}

In this case you will end up with a From header looking like this:
\begin{lyxcode}
From:~=?ISO-8859-1?Q?Thomas\_L=F8cke?=~<thomas@12boo.net>
\end{lyxcode}
So bear in mind that it is your responsibility to encode that data
as you need, and then set the \emph{Character\_Set} parameters accordingly.

The \emph{Recipient\_Kind} type define the kind of recipient that
is being added to an email. If you've worked with email, these three
should be familiar to you:
\begin{enumerate}
\item Bcc
\item Cc
\item To
\end{enumerate}
When adding recipients to an email \emph{Structure} the default is
To, but since not all recipients are equal, you have the 

The \emph{Structure} type is at the core of it all. You declare an
object to be of the \emph{Structure} type, and then you use the \emph{Yolk.Email.Composer}
facilities to build and send the email.


\section{Yolk.Email.Composer}

The actual tools for building and sending an email is found in this
package. Here are tools for building emails from the ground up and
there are a few convenience procedures if you just need to send a
simple email with no bells or whistles.

I'm not going to go through ever procedure in this package, instead
I'll show an example on how to build an email from the ground up and
how to use one of the convenience procedures.


\subsection{Building and sending an email, the easy way}

There are two convenience procedures in \emph{Yolk.Email.Composer}
for sending emails without having to do a whole lot of work/thinking.
They are both named \emph{Send} and they both look like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Send      
  (ES             : in out Structure;       
   From_Address   : in     String;       
   From_Name      : in     String := "";       
   To_Address     : in     String;       
   To_Name        : in     String := "";       
   Subject        : in     String;       
   Text_Part      : in     String;       
   SMTP_Server    : in     String := "localhost";       
   SMTP_Port      : in     Positive := 25;       
   Charset        : in     Character_Set := US_ASCII);    
   
procedure Send      
  (ES             : in out Structure;       
   From_Address   : in     String;       
   From_Name      : in     String := "";       
   To_Address     : in     String;       
   To_Name        : in     String := "";       
   Subject        : in     String;       
   Text_Part      : in     String;       
   HTML_Part      : in     String;       
   SMTP_Server    : in     String := "localhost";       
   SMTP_Port      : in     Positive := 25;       
   Charset        : in     Character_Set := US_ASCII);
\end{lstlisting}
%
\end{minipage}

As you can see, the only difference between these two is that the
first one sends plain text emails, while the second one sends \emph{multipart/alternative}
with both plain text and HTML parts. Usage is as simple as:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   use Yolk.Email;

   Email : Structure;
begin
   Composer.Send (ES           => Email,
                  From_Address => "thomas@12boo.net",
                  From_Name    => "Thomas Løcke",
                  To_Address   => "tl@ada-dk.org",
                  To_Name      => "Me",
                  Subject      => "Is this thing on?",
                  Text_Part    => "Hey you!",
                  Charset      => ISO_8859_1);
               
   if Composer.Is_Send (Email) then
      --  Success!               
   else                   
      --  Failure!
   end if;
end;
\end{lstlisting}
%
\end{minipage}

It is possible, and allowed, to call some of the various other procedures
prior to calling one of these. If for example you want to add a custom
header, it can be done like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   use Yolk.Email;

   Email : Structure;
begin
   Composer.Add_Custom_Header (ES      => Email,
                               Name    => "User-Agent",
                               Value   => "My User Agent");

   Composer.Send (ES           => Email,
                  From_Address => "thomas@12boo.net",
                  From_Name    => "Thomas Løcke",
                  To_Address   => "tl@ada-dk.org",
                  To_Name      => "Me",
                  Subject      => "Is this thing on?",
                  Text_Part    => "Hey you!",
                  Charset      => ISO_8859_1);
               
   if Composer.Is_Send (Email) then
      --  Success!               
   else                   
      --  Failure!
   end if;
end;
\end{lstlisting}
%
\end{minipage}

And with that, the header \emph{User-Agent:} is now added to the email:
\begin{lyxcode}
User-Agent:~My~User~Agent
\end{lyxcode}
It hardly gets any easier than that. Lets move on and see how the
above is accomplished the hard way.


\subsection{Building and sending email, the hard way}

It is possible to build an email from the ground up, which obviously
allows for a more fine grained control over what is added. It is also
a bit more complicated, but not much. Lets try and mimick the easy
examples, the {}``hard'' way:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
   use Yolk.Email;

   Email : Structure;
begin
   Composer.Add_Custom_Header (ES      => Email,
                               Name    => "User-Agent",
                               Value   => "My User Agent");

   Composer.Add_From (ES      => Email,
                      Address => "thomas@12boo.net",
                      Name    => "Thomas Løcke",
                      Charset => ISO_8859_1);

   Composer.Add_Recipient (ES      => Email,
                           Address => "tl@ada-dk.org",
                           Name    => "Me");
 
   Composer.Set_Subject (ES      => Email,
                         Subject => "Is this thing on?");

   Composer.Set_Text_Part (ES => Email,
                           Part => "Hey you!");

   Composer.Add_SMTP_Server (ES   => Email,
                             Host => "localhost");
                           
   Composer.Send (ES => Email);
               
   if Composer.Is_Send (Email) then
      --  Success!               
   else                   
      --  Failure!
   end if;
end;
\end{lstlisting}
%
\end{minipage}

Harder yes, but really not all that much more difficult.


\section{Yolk.Handlers}

Most web applications will need to handle various static content,
such as PNG, HTML and CSS files. \emph{Yolk.Handlers} helps you accomplish
that, so you don't have to build your own handlers for these kinds
of files.

The following filetypes are supported by \emph{Yolk.Handlers}:
\begin{itemize}
\item CSS
\item GIF
\item HTML
\item ICO
\item JPG
\item JS
\item PNG
\item SVG
\item XML
\item XSL
\end{itemize}
The filetypes that are textual, are compressed according to the \emph{Yolk.Configuration}
setting \emph{Compress\_Static\_Content} parameter, and the various
regular expressions for identifying these filetypes are also defined
in \emph{Yolk.Configuration} by the \emph{Handler\_{*}} parameters.
These regular expressions are registered by the \emph{AWS.Services.Dispatchers.URI.Register\_Regexp}
procedure.

There's only one procedure in the \emph{Yolk.Handlers} package:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Set (RH : out AWS.Services.Dispatchers.URI.Handler);
\end{lstlisting}
%
\end{minipage}

You can see an example on how this is used in the demo file \emph{my\_handlers.adb}.
There's really very little reason not to use this package for handling
of static content, but it is of course not mandatory.


\section{Yolk.Log\_File\_Cleanup}

House-keeping is a very important task, and when dealing with HTTP
servers, one of those tasks involve keeping an eye on the ever growing
amount of access and error log files. To help automate this task we
have the \emph{Yolk.Log\_File\_Cleanup} package. This package contains
one procedure:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Delete      
  (Config_Object           : in AWS.Config.Object;       
   Web_Server              : in AWS.Server.HTTP;
   Amount_Of_Files_To_Keep : in Positive);
\end{lstlisting}
%
\end{minipage}

Whenever the \emph{Delete} procedure is called, the directory where
AWS keeps its log files is traversed and if more log files than \emph{Amount\_Of\_Files\_To\_Keep}
is found, then the oldest of these are deleted until the amount equals
\emph{Amount\_Of\_Files\_To\_Keep}. 

Note that \emph{Yolk.Log\_File\_Cleanup} only deals with the AWS acces
and error log files. In the demo file \emph{demo/src/yolk\_demo.adb}
there's an example on how to call this procedure using a task that
wakes up according to the configuration setting \emph{Log\_File\_Cleanup\_Interval}.

Be sure to read the \emph{Logging - Rotating And Regular} section
in the \emph{demo/exe/configuration/config.ini} file for more information
on the configuration parameters that affect this system.


\section{Yolk.Not\_Found}

This job of this package is to return a HTTP 404 status code and an
accompanying simple not found HTML page. It's sole function \emph{Generate}
is about as simple as they come:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
function Generate      
  (Request : in AWS.Status.Data)       
   return AWS.Response.Data;
\end{lstlisting}
%
\end{minipage}

It relies on the template file \emph{demo/exe/templates/system/404.tmpl}
to generate the generic 404 HTML page, so if you want to use \emph{Yolk.Not\_Found}
in your own application, then remember to bring along this file. Where
the \emph{404.tmpl} is placed is defined in the configuration parameter
\emph{System\_Templates\_Path}.

Also worth noting is that the \emph{Yolk.Not\_Found.Generate} function
is used as the default callback in the demo application. This means
that all requested resources that doesn't match a registered dispatcher,
is served by \emph{Yolk.Not\_Found.Generate} ie. a 404 is returned.
See the \emph{demo/src/my\_handlers.adb} file for more information.


\section{Yolk.Process\_Control}

With \emph{Yolk.Process\_Control} you get the ability to control your
application using the SIGINT, SIGPWR and SIGTERM signals. You also
get a PID file placed next to your executable, which coupled with
the \emph{demo/tools/rc.yolk} script gives you a rather nice and simple
way of starting and stopping your application.


\subsection{Exceptions}

These are:
\begin{itemize}
\item \emph{Cannot\_Create\_PID\_File}. Is raised if the PID file cannot
be created, eg. if the application lacks permissions to write to the
directory where the executable is located.
\item \emph{Cannot\_Delete\_PID\_File}. Is raised if the PID file cannot
be deleted, eg. if the application lacks permissions to write to the
directory where the executable is located, or to the PID file itself.
\item \emph{PID\_File\_Exists}. Is raised when the PID file already exists,
ie. the application is already running or it was shutdown incorrectly.
\end{itemize}

\subsection{Using Yolk.Process\_Control}

When you use the \emph{Yolk.Process\_Control} package the \emph{Unreserve\_All\_Interrupts}
pragma is used. This means that depending on the compiler used one
or more interrupt signals may be affected. In the case of the GNAT
compiler, this is specifically mentioned in the source of the \emph{Ada.Interrupts.Names}
package:
\begin{quote}
-- The pragma Unreserve\_All\_Interrupts affects the following signal(s):

-- SIGINT: made available for Ada handler
\end{quote}
Since neither SIGPWR or SIGTERM are reserved by the compiler, the
\emph{Yolk.Process\_Control} package is able to assume control of
these signals. You can read more about the \href{http://gcc.gnu.org/onlinedocs/gnat_rm/Pragma-Unreserve_005fAll_005fInterrupts.html}{pragma Unreserve\_{}All\_{}Interrupts here}.
If you compile Yolk with a different compiler than GNAT, then please
check if one of the affected signals are reserved.

There are two procedures in the \emph{Yolk.Process\_Control} package:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Stop;

procedure Wait;
\end{lstlisting}
%
\end{minipage}

When you call the \emph{Wait} procedure, you basically enter an endless
loop that doesn't stop until
\begin{enumerate}
\item The \emph{Stop} procedure is called
\item The application receives a SIGINT, SIGPWR or SIGTERM signal
\end{enumerate}
This is quite handy for applications, that need some sort of loop
to keep them from terminating. You can see an example on how this
can be done in the \emph{demo/src/yolk\_demo.adb} file.

When \emph{Wait} is called, subsequent calls to \emph{Wait} are ignored,
unless a call to \emph{Stop} has been made or the application has
received one of the SIGINT, SIGPWR or SIGTERM signals. So it's perfectly
valid to do:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
Wait;
--  Stop called from somewhere in the app
--  Do something...
Wait;
--  The app receives a SIGINT signal
--  Do something...
Wait;
\end{lstlisting}
%
\end{minipage}

Whether or not this is actually useful I don't know, but it is possible.


\section{Yolk.Process\_Owner}

When it is necessary to change the owner of a process, the \emph{Yolk.Process\_Owner}
package is the solution. Obviously this can also be done when starting
the application, using various shell tricks, but I find it it much
cleaner to just let the application handle it by itself.


\subsection{Exceptions}

There's only one:
\begin{enumerate}
\item \emph{Username\_Does\_Not\_Exist}. This is raised if the given username
doesn't exist on the system.
\end{enumerate}

\subsection{Using Yolk.Process\_Owner}

There's only a single procedure in this package and its specification
looks like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Set_User      
  (Username : in String);    
  --  Set the process owner to Username.
\end{lstlisting}
%
\end{minipage}

Please note that when changing the user ID of the application with
\emph{Set\_User}, the group ID is changed to the first group the given
user is a member of.

Usage is as simple as expected:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
declare
begin
   Set_User (Username => "billybob");
exception
   when Username_Does_Not_Exist =>
      --  User is missing. Do something!
end;
\end{lstlisting}
%
\end{minipage}

In the file \emph{demo/src/yolk\_demo.adb} you'll find that \emph{Yolk.Process\_Owner.Set\_User}
is used in conjunction with the \emph{Yolk.Configuration.Yolk\_User}
parameter.


\section{Yolk.Rotating\_Log}

This package provides the ability to write log data to three predefined
log traces:
\begin{enumerate}
\item Error
\item Info
\item SQL
\end{enumerate}
These traces correspond with the components of the \emph{Yolk.Rotating\_Log.Trace\_Handles}
enumeration type. Data written to one of these traces are written
to files and these files are automatically rotated when they reach
a specified size. The rotation happens according to a {}``slot''
system, so you don't have to worry about cleaning away old log files
on a regular basis. The slot system works by appending a slot number
to each log file, so if you set the configuration parameter \emph{Max\_Slot\_Count}
to 3, then when starting the rotating log system you'll get a file
named \emph{Foo-rotating-INFO-1.log} (if your application is named
Foo) and when that file reach the \emph{Rotating\_Log\_Size\_Limit}
it is rotated to \emph{Foo-rotating-INFO-2.log} and so on and so forth.
When the last slot rotates, it starts all over with 1.

This system has the obvious advantage of never growing beyond a known
limited size. On the other hand it has the disadvantage of not being
very good at keeping old log data readily at hand, as everything is
going to get overwritten sooner or later.

For more information, take a look at the \emph{Logging - Rotating
And Regular} section of the \emph{demo/exe/configuration/config.ini}
file.

Note that this package handles all log data generated by the \emph{GNATCOLL.SQL}
packages. See the \emph{demo/exe/configuration/config.ini} for how
to enable/disable this output.


\subsection{Exceptions}

These are:
\begin{itemize}
\item \emph{Cannot\_Create\_Log\_File}. Is raised when it's not possible
to create one of the rotating log files.
\item \emph{Cannot\_Write\_To\_Log\_File}. Is raised when it's not possible
to write to one of the rotating log files.
\end{itemize}

\subsection{Starting the rotating log files}

It's not enough to simply \emph{with} the package, you have to start
the rotating log system before you can actually use it for anything.
This is done with the aptly named \emph{Start\_Rotating\_Logs} procedure:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Start_Rotating_Logs
  (Emit_Warning_If_Already_Running : Boolean := True);
\end{lstlisting}
%
\end{minipage}

Setting the \emph{Emit\_Warning\_If\_Already\_Running} to \emph{False}
will make sure that a second call to \emph{Start\_Rotating\_Logs}
won't emit a warning message on the Info trace.


\subsection{Writing log data}

With the rotating log system started, writing data to it is a simple
matter of calling the \emph{Trace} procedure. It looks like this:

%
\begin{minipage}[t]{1\columnwidth}%

\begin{lstlisting}[basicstyle={\small\sffamily},frame=tblr,language=Ada,showstringspaces=false,tabsize=3,xleftmargin=1em,xrightmargin=1em]
procedure Trace      
  (Handle     : in Trace_Handles;       
   Log_String : in String);
\end{lstlisting}
%
\end{minipage}
\end{document}
